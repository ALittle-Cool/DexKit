include "encode_value.fbs";
include "enums.fbs";
include "ranges.fbs";

namespace dexkit.schema;

table StringMatcher {
    value: string;
    type: StringMatchType;
    ignore_case: bool;
}

table AccessFlagsMatcher {
    flags: uint32;
    match_type: MatchType;
}

table TargetElementTypesMatcher {
    contain_types: [TargetElementType];
}

table EnumMatcher {
    enum_class: ClassMatcher;
    enum_name: StringMatcher;
}

union AnnotationElementValueMatcher {
    EncodeValueBoolean,
    EncodeValueByte,
    EncodeValueShort,
    EncodeValueChar,
    EncodeValueInt,
    EncodeValueLong,
    EncodeValueFloat,
    EncodeValueDouble,
    StringMatcher,
    ClassMatcher,
    EnumMatcher,
    AnnotationElementsMatcher,
    AnnotationMatcher,
}

table OptionalAnnotationElementValueMatcher {
    value: AnnotationElementValueMatcher;
}

table AnnotationElementMatcher {
    name: StringMatcher;
    value: OptionalAnnotationElementValueMatcher;
}

table OptionalAnnotationElementMatcher {
    element: AnnotationElementMatcher;
}

table AnnotationElementsMatcher {
    element_count: IntRange;
    match_type: MatchType;
    elements: [OptionalAnnotationElementMatcher];
}

table AnnotationMatcher {
    type_name: StringMatcher;
    target_element_types: TargetElementTypesMatcher;
    policy: RetentionPolicyType;
    annotations: AnnotationsMatcher;
    elements: AnnotationElementsMatcher;
}

table AnnotationsMatcher {
    annotaion_count: IntRange;
    contain_annotations: [AnnotationMatcher];
}

table ParameterMatcher {
    prameter_type: ClassMatcher;
    annotations: AnnotationsMatcher;
}

table OptionalParameterMatcher {
    parameter: ParameterMatcher;
}

table ParametersMatcher {
    parameter_count: IntRange;
    match_type: MatchType;
    parameters: [OptionalParameterMatcher];
}

table OpCodesMatcher {
    match_type: OpCodeMatchType;
    op_codes: [int16];
}

table UsingFieldMatcher {
    using_type: UsingType;
    field: FieldMatcher;
}

union Number {
    EncodeValueShort,
    EncodeValueInt,
    EncodeValueLong,
    EncodeValueFloat,
    EncodeValueDouble,
}

table UsingNumberMatcher {
    number: Number;
    using_type: UsingType;
}

table MethodMatcher {
    method_name: StringMatcher;
    access_flags: AccessFlagsMatcher;
    declaring_class: ClassMatcher;
    return_type: ClassMatcher;
    parameters: ParametersMatcher;
    annotations: AnnotationsMatcher;
    op_codes: OpCodesMatcher;
    using_strings: [StringMatcher];
    using_fiels: [UsingFieldMatcher];
    using_numbers: [UsingNumberMatcher];
    invoke_methods: MethodsMatcher;
    call_methods: MethodsMatcher;
}

table MethodsMatcher {
    contain_methods: [MethodMatcher];
    method_count: IntRange;
}

table InterfacesMatcher {
    contain_interfaces: [ClassMatcher];
    interface_count: IntRange;
}

table FieldMatcher {
    access_flags: AccessFlagsMatcher;
    declaring_class: ClassMatcher;
    type_class: ClassMatcher;
    annotations: AnnotationsMatcher;
    get_methods: MethodsMatcher;
    put_methods: MethodsMatcher;
}

table FieldsMatcher {
    contain_fields: [FieldMatcher];
    field_count: IntRange;
}

table ClassMatcher {
    package_name: StringMatcher;
    smali_source: StringMatcher;
    simple_name: StringMatcher;
    access_flags: AccessFlagsMatcher;
    super_class: ClassMatcher;
    interfaces: InterfacesMatcher;
    annotations: AnnotationsMatcher;
    fields: FieldsMatcher;
    methods: MethodsMatcher;
    using_strings: [StringMatcher];
}

table BatchUsingStringsMatcher {
    union_key: string;
    using_strings: [StringMatcher];
}