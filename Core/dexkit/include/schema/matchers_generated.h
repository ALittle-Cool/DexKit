// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATCHERS_DEXKIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_MATCHERS_DEXKIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "encode_value_generated.h"
#include "enums_generated.h"
#include "ranges_generated.h"

namespace dexkit {
namespace schema {

struct StringMatcher;
struct StringMatcherBuilder;

struct AccessFlagsMatcher;
struct AccessFlagsMatcherBuilder;

struct TargetElementTypesMatcher;
struct TargetElementTypesMatcherBuilder;

struct OptionalAnnotationEncodeValueMatcher;
struct OptionalAnnotationEncodeValueMatcherBuilder;

struct AnnotationElementMatcher;
struct AnnotationElementMatcherBuilder;

struct OptionalAnnotationElementMatcher;
struct OptionalAnnotationElementMatcherBuilder;

struct AnnotationEncodeArrayMatcher;
struct AnnotationEncodeArrayMatcherBuilder;

struct AnnotationMatcher;
struct AnnotationMatcherBuilder;

struct AnnotationsMatcher;
struct AnnotationsMatcherBuilder;

struct ParameterMatcher;
struct ParameterMatcherBuilder;

struct OptionalParameterMatcher;
struct OptionalParameterMatcherBuilder;

struct ParametersMatcher;
struct ParametersMatcherBuilder;

struct OpCodesMatcher;
struct OpCodesMatcherBuilder;

struct UsingFieldMatcher;
struct UsingFieldMatcherBuilder;

struct UsingNumberMatcher;
struct UsingNumberMatcherBuilder;

struct MethodMatcher;
struct MethodMatcherBuilder;

struct MethodsMatcher;
struct MethodsMatcherBuilder;

struct InterfacesMatcher;
struct InterfacesMatcherBuilder;

struct FieldMatcher;
struct FieldMatcherBuilder;

struct FieldsMatcher;
struct FieldsMatcherBuilder;

struct ClassMatcher;
struct ClassMatcherBuilder;

struct BatchUsingStringsMatcher;
struct BatchUsingStringsMatcherBuilder;

enum class AnnotationEncodeValueMatcher : uint8_t {
  NONE = 0,
  EncodeValueBoolean = 1,
  EncodeValueByte = 2,
  EncodeValueShort = 3,
  EncodeValueChar = 4,
  EncodeValueInt = 5,
  EncodeValueLong = 6,
  EncodeValueFloat = 7,
  EncodeValueDouble = 8,
  StringMatcher = 9,
  ClassMatcher = 10,
  FieldMatcher = 11,
  AnnotationEncodeArrayMatcher = 12,
  AnnotationMatcher = 13
};

inline const AnnotationEncodeValueMatcher (&EnumValuesAnnotationEncodeValueMatcher())[14] {
  static const AnnotationEncodeValueMatcher values[] = {
    AnnotationEncodeValueMatcher::NONE,
    AnnotationEncodeValueMatcher::EncodeValueBoolean,
    AnnotationEncodeValueMatcher::EncodeValueByte,
    AnnotationEncodeValueMatcher::EncodeValueShort,
    AnnotationEncodeValueMatcher::EncodeValueChar,
    AnnotationEncodeValueMatcher::EncodeValueInt,
    AnnotationEncodeValueMatcher::EncodeValueLong,
    AnnotationEncodeValueMatcher::EncodeValueFloat,
    AnnotationEncodeValueMatcher::EncodeValueDouble,
    AnnotationEncodeValueMatcher::StringMatcher,
    AnnotationEncodeValueMatcher::ClassMatcher,
    AnnotationEncodeValueMatcher::FieldMatcher,
    AnnotationEncodeValueMatcher::AnnotationEncodeArrayMatcher,
    AnnotationEncodeValueMatcher::AnnotationMatcher
  };
  return values;
}

inline const char * const *EnumNamesAnnotationEncodeValueMatcher() {
  static const char * const names[15] = {
    "NONE",
    "EncodeValueBoolean",
    "EncodeValueByte",
    "EncodeValueShort",
    "EncodeValueChar",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    "StringMatcher",
    "ClassMatcher",
    "FieldMatcher",
    "AnnotationEncodeArrayMatcher",
    "AnnotationMatcher",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationEncodeValueMatcher(AnnotationEncodeValueMatcher e) {
  if (::flatbuffers::IsOutRange(e, AnnotationEncodeValueMatcher::NONE, AnnotationEncodeValueMatcher::AnnotationMatcher)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationEncodeValueMatcher()[index];
}

template<typename T> struct AnnotationEncodeValueMatcherTraits {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::NONE;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueBoolean> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueBoolean;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueByte> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueByte;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueShort> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueShort;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueChar> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueChar;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueInt> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueInt;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueLong> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueLong;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueFloat> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueFloat;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::EncodeValueDouble> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::EncodeValueDouble;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::StringMatcher> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::StringMatcher;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::ClassMatcher> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::ClassMatcher;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::FieldMatcher> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::FieldMatcher;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::AnnotationEncodeArrayMatcher> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::AnnotationEncodeArrayMatcher;
};

template<> struct AnnotationEncodeValueMatcherTraits<dexkit::schema::AnnotationMatcher> {
  static const AnnotationEncodeValueMatcher enum_value = AnnotationEncodeValueMatcher::AnnotationMatcher;
};

bool VerifyAnnotationEncodeValueMatcher(::flatbuffers::Verifier &verifier, const void *obj, AnnotationEncodeValueMatcher type);
bool VerifyAnnotationEncodeValueMatcherVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationEncodeValueMatcher> *types);

enum class Number : uint8_t {
  NONE = 0,
  EncodeValueShort = 1,
  EncodeValueInt = 2,
  EncodeValueLong = 3,
  EncodeValueFloat = 4,
  EncodeValueDouble = 5
};

inline const Number (&EnumValuesNumber())[6] {
  static const Number values[] = {
    Number::NONE,
    Number::EncodeValueShort,
    Number::EncodeValueInt,
    Number::EncodeValueLong,
    Number::EncodeValueFloat,
    Number::EncodeValueDouble
  };
  return values;
}

inline const char * const *EnumNamesNumber() {
  static const char * const names[7] = {
    "NONE",
    "EncodeValueShort",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    nullptr
  };
  return names;
}

inline const char *EnumNameNumber(Number e) {
  if (::flatbuffers::IsOutRange(e, Number::NONE, Number::EncodeValueDouble)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNumber()[index];
}

template<typename T> struct NumberTraits {
  static const Number enum_value = Number::NONE;
};

template<> struct NumberTraits<dexkit::schema::EncodeValueShort> {
  static const Number enum_value = Number::EncodeValueShort;
};

template<> struct NumberTraits<dexkit::schema::EncodeValueInt> {
  static const Number enum_value = Number::EncodeValueInt;
};

template<> struct NumberTraits<dexkit::schema::EncodeValueLong> {
  static const Number enum_value = Number::EncodeValueLong;
};

template<> struct NumberTraits<dexkit::schema::EncodeValueFloat> {
  static const Number enum_value = Number::EncodeValueFloat;
};

template<> struct NumberTraits<dexkit::schema::EncodeValueDouble> {
  static const Number enum_value = Number::EncodeValueDouble;
};

bool VerifyNumber(::flatbuffers::Verifier &verifier, const void *obj, Number type);
bool VerifyNumberVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Number> *types);

struct StringMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4,
    VT_MATCH_TYPE = 6,
    VT_IGNORE_CASE = 8
  };
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  dexkit::schema::StringMatchType match_type() const {
    return static_cast<dexkit::schema::StringMatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  bool ignore_case() const {
    return GetField<uint8_t>(VT_IGNORE_CASE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IGNORE_CASE, 1) &&
           verifier.EndTable();
  }
};

struct StringMatcherBuilder {
  typedef StringMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringMatcher::VT_VALUE, value);
  }
  void add_match_type(dexkit::schema::StringMatchType match_type) {
    fbb_.AddElement<int8_t>(StringMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_ignore_case(bool ignore_case) {
    fbb_.AddElement<uint8_t>(StringMatcher::VT_IGNORE_CASE, static_cast<uint8_t>(ignore_case), 0);
  }
  explicit StringMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringMatcher> CreateStringMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0,
    dexkit::schema::StringMatchType match_type = dexkit::schema::StringMatchType::Contains,
    bool ignore_case = false) {
  StringMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_ignore_case(ignore_case);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct StringMatcher::Traits {
  using type = StringMatcher;
  static auto constexpr Create = CreateStringMatcher;
};

inline ::flatbuffers::Offset<StringMatcher> CreateStringMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *value = nullptr,
    dexkit::schema::StringMatchType match_type = dexkit::schema::StringMatchType::Contains,
    bool ignore_case = false) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return dexkit::schema::CreateStringMatcher(
      _fbb,
      value__,
      match_type,
      ignore_case);
}

struct AccessFlagsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccessFlagsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_MATCH_TYPE = 6
  };
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct AccessFlagsMatcherBuilder {
  typedef AccessFlagsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(AccessFlagsMatcher::VT_FLAGS, flags, 0);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(AccessFlagsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  explicit AccessFlagsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccessFlagsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccessFlagsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccessFlagsMatcher> CreateAccessFlagsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t flags = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain) {
  AccessFlagsMatcherBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct AccessFlagsMatcher::Traits {
  using type = AccessFlagsMatcher;
  static auto constexpr Create = CreateAccessFlagsMatcher;
};

struct TargetElementTypesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TargetElementTypesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPES = 4,
    VT_MATCH_TYPE = 6
  };
  const ::flatbuffers::Vector<dexkit::schema::TargetElementType> *types() const {
    return GetPointer<const ::flatbuffers::Vector<dexkit::schema::TargetElementType> *>(VT_TYPES);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPES) &&
           verifier.VerifyVector(types()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct TargetElementTypesMatcherBuilder {
  typedef TargetElementTypesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_types(::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::TargetElementType>> types) {
    fbb_.AddOffset(TargetElementTypesMatcher::VT_TYPES, types);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(TargetElementTypesMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  explicit TargetElementTypesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TargetElementTypesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TargetElementTypesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TargetElementTypesMatcher> CreateTargetElementTypesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::TargetElementType>> types = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain) {
  TargetElementTypesMatcherBuilder builder_(_fbb);
  builder_.add_types(types);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct TargetElementTypesMatcher::Traits {
  using type = TargetElementTypesMatcher;
  static auto constexpr Create = CreateTargetElementTypesMatcher;
};

inline ::flatbuffers::Offset<TargetElementTypesMatcher> CreateTargetElementTypesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<dexkit::schema::TargetElementType> *types = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain) {
  auto types__ = types ? _fbb.CreateVector<dexkit::schema::TargetElementType>(*types) : 0;
  return dexkit::schema::CreateTargetElementTypesMatcher(
      _fbb,
      types__,
      match_type);
}

struct OptionalAnnotationEncodeValueMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalAnnotationEncodeValueMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  dexkit::schema::AnnotationEncodeValueMatcher value_type() const {
    return static_cast<dexkit::schema::AnnotationEncodeValueMatcher>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const dexkit::schema::EncodeValueBoolean *value_as_EncodeValueBoolean() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueBoolean ? static_cast<const dexkit::schema::EncodeValueBoolean *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueByte *value_as_EncodeValueByte() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueByte ? static_cast<const dexkit::schema::EncodeValueByte *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueShort *value_as_EncodeValueShort() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueShort ? static_cast<const dexkit::schema::EncodeValueShort *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueChar *value_as_EncodeValueChar() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueChar ? static_cast<const dexkit::schema::EncodeValueChar *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueInt *value_as_EncodeValueInt() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueInt ? static_cast<const dexkit::schema::EncodeValueInt *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueLong *value_as_EncodeValueLong() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueLong ? static_cast<const dexkit::schema::EncodeValueLong *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueFloat *value_as_EncodeValueFloat() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueFloat ? static_cast<const dexkit::schema::EncodeValueFloat *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueDouble *value_as_EncodeValueDouble() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::EncodeValueDouble ? static_cast<const dexkit::schema::EncodeValueDouble *>(value()) : nullptr;
  }
  const dexkit::schema::StringMatcher *value_as_StringMatcher() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::StringMatcher ? static_cast<const dexkit::schema::StringMatcher *>(value()) : nullptr;
  }
  const dexkit::schema::ClassMatcher *value_as_ClassMatcher() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::ClassMatcher ? static_cast<const dexkit::schema::ClassMatcher *>(value()) : nullptr;
  }
  const dexkit::schema::FieldMatcher *value_as_FieldMatcher() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::FieldMatcher ? static_cast<const dexkit::schema::FieldMatcher *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationEncodeArrayMatcher *value_as_AnnotationEncodeArrayMatcher() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::AnnotationEncodeArrayMatcher ? static_cast<const dexkit::schema::AnnotationEncodeArrayMatcher *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationMatcher *value_as_AnnotationMatcher() const {
    return value_type() == dexkit::schema::AnnotationEncodeValueMatcher::AnnotationMatcher ? static_cast<const dexkit::schema::AnnotationMatcher *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnnotationEncodeValueMatcher(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dexkit::schema::EncodeValueBoolean *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueBoolean>() const {
  return value_as_EncodeValueBoolean();
}

template<> inline const dexkit::schema::EncodeValueByte *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueByte>() const {
  return value_as_EncodeValueByte();
}

template<> inline const dexkit::schema::EncodeValueShort *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueShort>() const {
  return value_as_EncodeValueShort();
}

template<> inline const dexkit::schema::EncodeValueChar *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueChar>() const {
  return value_as_EncodeValueChar();
}

template<> inline const dexkit::schema::EncodeValueInt *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueInt>() const {
  return value_as_EncodeValueInt();
}

template<> inline const dexkit::schema::EncodeValueLong *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueLong>() const {
  return value_as_EncodeValueLong();
}

template<> inline const dexkit::schema::EncodeValueFloat *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueFloat>() const {
  return value_as_EncodeValueFloat();
}

template<> inline const dexkit::schema::EncodeValueDouble *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::EncodeValueDouble>() const {
  return value_as_EncodeValueDouble();
}

template<> inline const dexkit::schema::StringMatcher *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::StringMatcher>() const {
  return value_as_StringMatcher();
}

template<> inline const dexkit::schema::ClassMatcher *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::ClassMatcher>() const {
  return value_as_ClassMatcher();
}

template<> inline const dexkit::schema::FieldMatcher *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::FieldMatcher>() const {
  return value_as_FieldMatcher();
}

template<> inline const dexkit::schema::AnnotationEncodeArrayMatcher *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::AnnotationEncodeArrayMatcher>() const {
  return value_as_AnnotationEncodeArrayMatcher();
}

template<> inline const dexkit::schema::AnnotationMatcher *OptionalAnnotationEncodeValueMatcher::value_as<dexkit::schema::AnnotationMatcher>() const {
  return value_as_AnnotationMatcher();
}

struct OptionalAnnotationEncodeValueMatcherBuilder {
  typedef OptionalAnnotationEncodeValueMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(dexkit::schema::AnnotationEncodeValueMatcher value_type) {
    fbb_.AddElement<uint8_t>(OptionalAnnotationEncodeValueMatcher::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(OptionalAnnotationEncodeValueMatcher::VT_VALUE, value);
  }
  explicit OptionalAnnotationEncodeValueMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalAnnotationEncodeValueMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalAnnotationEncodeValueMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalAnnotationEncodeValueMatcher> CreateOptionalAnnotationEncodeValueMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    dexkit::schema::AnnotationEncodeValueMatcher value_type = dexkit::schema::AnnotationEncodeValueMatcher::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  OptionalAnnotationEncodeValueMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct OptionalAnnotationEncodeValueMatcher::Traits {
  using type = OptionalAnnotationEncodeValueMatcher;
  static auto constexpr Create = CreateOptionalAnnotationEncodeValueMatcher;
};

struct AnnotationElementMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const dexkit::schema::StringMatcher *name() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_NAME);
  }
  const dexkit::schema::OptionalAnnotationEncodeValueMatcher *value() const {
    return GetPointer<const dexkit::schema::OptionalAnnotationEncodeValueMatcher *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyTable(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementMatcherBuilder {
  typedef AnnotationElementMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<dexkit::schema::StringMatcher> name) {
    fbb_.AddOffset(AnnotationElementMatcher::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<dexkit::schema::OptionalAnnotationEncodeValueMatcher> value) {
    fbb_.AddOffset(AnnotationElementMatcher::VT_VALUE, value);
  }
  explicit AnnotationElementMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementMatcher> CreateAnnotationElementMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> name = 0,
    ::flatbuffers::Offset<dexkit::schema::OptionalAnnotationEncodeValueMatcher> value = 0) {
  AnnotationElementMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AnnotationElementMatcher::Traits {
  using type = AnnotationElementMatcher;
  static auto constexpr Create = CreateAnnotationElementMatcher;
};

struct OptionalAnnotationElementMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalAnnotationElementMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT = 4
  };
  const dexkit::schema::AnnotationElementMatcher *element() const {
    return GetPointer<const dexkit::schema::AnnotationElementMatcher *>(VT_ELEMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT) &&
           verifier.VerifyTable(element()) &&
           verifier.EndTable();
  }
};

struct OptionalAnnotationElementMatcherBuilder {
  typedef OptionalAnnotationElementMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_element(::flatbuffers::Offset<dexkit::schema::AnnotationElementMatcher> element) {
    fbb_.AddOffset(OptionalAnnotationElementMatcher::VT_ELEMENT, element);
  }
  explicit OptionalAnnotationElementMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalAnnotationElementMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalAnnotationElementMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalAnnotationElementMatcher> CreateOptionalAnnotationElementMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::AnnotationElementMatcher> element = 0) {
  OptionalAnnotationElementMatcherBuilder builder_(_fbb);
  builder_.add_element(element);
  return builder_.Finish();
}

struct OptionalAnnotationElementMatcher::Traits {
  using type = OptionalAnnotationElementMatcher;
  static auto constexpr Create = CreateOptionalAnnotationElementMatcher;
};

struct AnnotationEncodeArrayMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationEncodeArrayMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTS = 4,
    VT_MATCH_TYPE = 6,
    VT_ELEMENT_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>> *elements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>> *>(VT_ELEMENTS);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *element_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_ELEMENT_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_ELEMENT_COUNT) &&
           verifier.VerifyTable(element_count()) &&
           verifier.EndTable();
  }
};

struct AnnotationEncodeArrayMatcherBuilder {
  typedef AnnotationEncodeArrayMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>>> elements) {
    fbb_.AddOffset(AnnotationEncodeArrayMatcher::VT_ELEMENTS, elements);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(AnnotationEncodeArrayMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_element_count(::flatbuffers::Offset<dexkit::schema::IntRange> element_count) {
    fbb_.AddOffset(AnnotationEncodeArrayMatcher::VT_ELEMENT_COUNT, element_count);
  }
  explicit AnnotationEncodeArrayMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationEncodeArrayMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationEncodeArrayMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationEncodeArrayMatcher> CreateAnnotationEncodeArrayMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>>> elements = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> element_count = 0) {
  AnnotationEncodeArrayMatcherBuilder builder_(_fbb);
  builder_.add_element_count(element_count);
  builder_.add_elements(elements);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct AnnotationEncodeArrayMatcher::Traits {
  using type = AnnotationEncodeArrayMatcher;
  static auto constexpr Create = CreateAnnotationEncodeArrayMatcher;
};

inline ::flatbuffers::Offset<AnnotationEncodeArrayMatcher> CreateAnnotationEncodeArrayMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>> *elements = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> element_count = 0) {
  auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::OptionalAnnotationElementMatcher>>(*elements) : 0;
  return dexkit::schema::CreateAnnotationEncodeArrayMatcher(
      _fbb,
      elements__,
      match_type,
      element_count);
}

struct AnnotationMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_NAME = 4,
    VT_TARGET_ELEMENT_TYPES = 6,
    VT_POLICY = 8,
    VT_ANNOTATIONS = 10,
    VT_ELEMENTS = 12
  };
  const dexkit::schema::StringMatcher *type_name() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_TYPE_NAME);
  }
  const dexkit::schema::TargetElementTypesMatcher *target_element_types() const {
    return GetPointer<const dexkit::schema::TargetElementTypesMatcher *>(VT_TARGET_ELEMENT_TYPES);
  }
  dexkit::schema::RetentionPolicyType policy() const {
    return static_cast<dexkit::schema::RetentionPolicyType>(GetField<int8_t>(VT_POLICY, 0));
  }
  const dexkit::schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const dexkit::schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const dexkit::schema::AnnotationEncodeArrayMatcher *elements() const {
    return GetPointer<const dexkit::schema::AnnotationEncodeArrayMatcher *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyTable(type_name()) &&
           VerifyOffset(verifier, VT_TARGET_ELEMENT_TYPES) &&
           verifier.VerifyTable(target_element_types()) &&
           VerifyField<int8_t>(verifier, VT_POLICY, 1) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyTable(elements()) &&
           verifier.EndTable();
  }
};

struct AnnotationMatcherBuilder {
  typedef AnnotationMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_name(::flatbuffers::Offset<dexkit::schema::StringMatcher> type_name) {
    fbb_.AddOffset(AnnotationMatcher::VT_TYPE_NAME, type_name);
  }
  void add_target_element_types(::flatbuffers::Offset<dexkit::schema::TargetElementTypesMatcher> target_element_types) {
    fbb_.AddOffset(AnnotationMatcher::VT_TARGET_ELEMENT_TYPES, target_element_types);
  }
  void add_policy(dexkit::schema::RetentionPolicyType policy) {
    fbb_.AddElement<int8_t>(AnnotationMatcher::VT_POLICY, static_cast<int8_t>(policy), 0);
  }
  void add_annotations(::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(AnnotationMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_elements(::flatbuffers::Offset<dexkit::schema::AnnotationEncodeArrayMatcher> elements) {
    fbb_.AddOffset(AnnotationMatcher::VT_ELEMENTS, elements);
  }
  explicit AnnotationMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMatcher> CreateAnnotationMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> type_name = 0,
    ::flatbuffers::Offset<dexkit::schema::TargetElementTypesMatcher> target_element_types = 0,
    dexkit::schema::RetentionPolicyType policy = dexkit::schema::RetentionPolicyType::Source,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationEncodeArrayMatcher> elements = 0) {
  AnnotationMatcherBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_annotations(annotations);
  builder_.add_target_element_types(target_element_types);
  builder_.add_type_name(type_name);
  builder_.add_policy(policy);
  return builder_.Finish();
}

struct AnnotationMatcher::Traits {
  using type = AnnotationMatcher;
  static auto constexpr Create = CreateAnnotationMatcher;
};

struct AnnotationsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATIONS = 4,
    VT_MATCH_TYPE = 6,
    VT_ANNOTAION_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>> *>(VT_ANNOTATIONS);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *annotaion_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_ANNOTAION_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           verifier.VerifyVectorOfTables(annotations()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_ANNOTAION_COUNT) &&
           verifier.VerifyTable(annotaion_count()) &&
           verifier.EndTable();
  }
};

struct AnnotationsMatcherBuilder {
  typedef AnnotationsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>>> annotations) {
    fbb_.AddOffset(AnnotationsMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(AnnotationsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_annotaion_count(::flatbuffers::Offset<dexkit::schema::IntRange> annotaion_count) {
    fbb_.AddOffset(AnnotationsMatcher::VT_ANNOTAION_COUNT, annotaion_count);
  }
  explicit AnnotationsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationsMatcher> CreateAnnotationsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>>> annotations = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> annotaion_count = 0) {
  AnnotationsMatcherBuilder builder_(_fbb);
  builder_.add_annotaion_count(annotaion_count);
  builder_.add_annotations(annotations);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct AnnotationsMatcher::Traits {
  using type = AnnotationsMatcher;
  static auto constexpr Create = CreateAnnotationsMatcher;
};

inline ::flatbuffers::Offset<AnnotationsMatcher> CreateAnnotationsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>> *annotations = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> annotaion_count = 0) {
  auto annotations__ = annotations ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationMatcher>>(*annotations) : 0;
  return dexkit::schema::CreateAnnotationsMatcher(
      _fbb,
      annotations__,
      match_type,
      annotaion_count);
}

struct ParameterMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTATIONS = 4,
    VT_PRAMETER_TYPE = 6
  };
  const dexkit::schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const dexkit::schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const dexkit::schema::ClassMatcher *prameter_type() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_PRAMETER_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_PRAMETER_TYPE) &&
           verifier.VerifyTable(prameter_type()) &&
           verifier.EndTable();
  }
};

struct ParameterMatcherBuilder {
  typedef ParameterMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotations(::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(ParameterMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_prameter_type(::flatbuffers::Offset<dexkit::schema::ClassMatcher> prameter_type) {
    fbb_.AddOffset(ParameterMatcher::VT_PRAMETER_TYPE, prameter_type);
  }
  explicit ParameterMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterMatcher> CreateParameterMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> prameter_type = 0) {
  ParameterMatcherBuilder builder_(_fbb);
  builder_.add_prameter_type(prameter_type);
  builder_.add_annotations(annotations);
  return builder_.Finish();
}

struct ParameterMatcher::Traits {
  using type = ParameterMatcher;
  static auto constexpr Create = CreateParameterMatcher;
};

struct OptionalParameterMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalParameterMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER = 4
  };
  const dexkit::schema::ParameterMatcher *parameter() const {
    return GetPointer<const dexkit::schema::ParameterMatcher *>(VT_PARAMETER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           verifier.VerifyTable(parameter()) &&
           verifier.EndTable();
  }
};

struct OptionalParameterMatcherBuilder {
  typedef OptionalParameterMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parameter(::flatbuffers::Offset<dexkit::schema::ParameterMatcher> parameter) {
    fbb_.AddOffset(OptionalParameterMatcher::VT_PARAMETER, parameter);
  }
  explicit OptionalParameterMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalParameterMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalParameterMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalParameterMatcher> CreateOptionalParameterMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::ParameterMatcher> parameter = 0) {
  OptionalParameterMatcherBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  return builder_.Finish();
}

struct OptionalParameterMatcher::Traits {
  using type = OptionalParameterMatcher;
  static auto constexpr Create = CreateOptionalParameterMatcher;
};

struct ParametersMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParametersMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETERS = 4,
    VT_MATCH_TYPE = 6,
    VT_PARAMETER_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>> *>(VT_PARAMETERS);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *parameter_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_PARAMETER_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARAMETER_COUNT) &&
           verifier.VerifyTable(parameter_count()) &&
           verifier.EndTable();
  }
};

struct ParametersMatcherBuilder {
  typedef ParametersMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>>> parameters) {
    fbb_.AddOffset(ParametersMatcher::VT_PARAMETERS, parameters);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(ParametersMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_parameter_count(::flatbuffers::Offset<dexkit::schema::IntRange> parameter_count) {
    fbb_.AddOffset(ParametersMatcher::VT_PARAMETER_COUNT, parameter_count);
  }
  explicit ParametersMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParametersMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParametersMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParametersMatcher> CreateParametersMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>>> parameters = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> parameter_count = 0) {
  ParametersMatcherBuilder builder_(_fbb);
  builder_.add_parameter_count(parameter_count);
  builder_.add_parameters(parameters);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct ParametersMatcher::Traits {
  using type = ParametersMatcher;
  static auto constexpr Create = CreateParametersMatcher;
};

inline ::flatbuffers::Offset<ParametersMatcher> CreateParametersMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>> *parameters = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> parameter_count = 0) {
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::OptionalParameterMatcher>>(*parameters) : 0;
  return dexkit::schema::CreateParametersMatcher(
      _fbb,
      parameters__,
      match_type,
      parameter_count);
}

struct OpCodesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OpCodesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP_CODES = 4,
    VT_MATCH_TYPE = 6
  };
  const ::flatbuffers::Vector<int16_t> *op_codes() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_OP_CODES);
  }
  dexkit::schema::OpCodeMatchType match_type() const {
    return static_cast<dexkit::schema::OpCodeMatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP_CODES) &&
           verifier.VerifyVector(op_codes()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct OpCodesMatcherBuilder {
  typedef OpCodesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op_codes(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> op_codes) {
    fbb_.AddOffset(OpCodesMatcher::VT_OP_CODES, op_codes);
  }
  void add_match_type(dexkit::schema::OpCodeMatchType match_type) {
    fbb_.AddElement<int8_t>(OpCodesMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  explicit OpCodesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OpCodesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OpCodesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OpCodesMatcher> CreateOpCodesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> op_codes = 0,
    dexkit::schema::OpCodeMatchType match_type = dexkit::schema::OpCodeMatchType::Contains) {
  OpCodesMatcherBuilder builder_(_fbb);
  builder_.add_op_codes(op_codes);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct OpCodesMatcher::Traits {
  using type = OpCodesMatcher;
  static auto constexpr Create = CreateOpCodesMatcher;
};

inline ::flatbuffers::Offset<OpCodesMatcher> CreateOpCodesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int16_t> *op_codes = nullptr,
    dexkit::schema::OpCodeMatchType match_type = dexkit::schema::OpCodeMatchType::Contains) {
  auto op_codes__ = op_codes ? _fbb.CreateVector<int16_t>(*op_codes) : 0;
  return dexkit::schema::CreateOpCodesMatcher(
      _fbb,
      op_codes__,
      match_type);
}

struct UsingFieldMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingFieldMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD = 4,
    VT_USING_TYPE = 6
  };
  const dexkit::schema::FieldMatcher *field() const {
    return GetPointer<const dexkit::schema::FieldMatcher *>(VT_FIELD);
  }
  dexkit::schema::UsingType using_type() const {
    return static_cast<dexkit::schema::UsingType>(GetField<int8_t>(VT_USING_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           VerifyField<int8_t>(verifier, VT_USING_TYPE, 1) &&
           verifier.EndTable();
  }
};

struct UsingFieldMatcherBuilder {
  typedef UsingFieldMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field(::flatbuffers::Offset<dexkit::schema::FieldMatcher> field) {
    fbb_.AddOffset(UsingFieldMatcher::VT_FIELD, field);
  }
  void add_using_type(dexkit::schema::UsingType using_type) {
    fbb_.AddElement<int8_t>(UsingFieldMatcher::VT_USING_TYPE, static_cast<int8_t>(using_type), 0);
  }
  explicit UsingFieldMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingFieldMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingFieldMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingFieldMatcher> CreateUsingFieldMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::FieldMatcher> field = 0,
    dexkit::schema::UsingType using_type = dexkit::schema::UsingType::Any) {
  UsingFieldMatcherBuilder builder_(_fbb);
  builder_.add_field(field);
  builder_.add_using_type(using_type);
  return builder_.Finish();
}

struct UsingFieldMatcher::Traits {
  using type = UsingFieldMatcher;
  static auto constexpr Create = CreateUsingFieldMatcher;
};

struct UsingNumberMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingNumberMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBER_TYPE = 4,
    VT_NUMBER = 6,
    VT_USING_TYPE = 8
  };
  dexkit::schema::Number number_type() const {
    return static_cast<dexkit::schema::Number>(GetField<uint8_t>(VT_NUMBER_TYPE, 0));
  }
  const void *number() const {
    return GetPointer<const void *>(VT_NUMBER);
  }
  template<typename T> const T *number_as() const;
  const dexkit::schema::EncodeValueShort *number_as_EncodeValueShort() const {
    return number_type() == dexkit::schema::Number::EncodeValueShort ? static_cast<const dexkit::schema::EncodeValueShort *>(number()) : nullptr;
  }
  const dexkit::schema::EncodeValueInt *number_as_EncodeValueInt() const {
    return number_type() == dexkit::schema::Number::EncodeValueInt ? static_cast<const dexkit::schema::EncodeValueInt *>(number()) : nullptr;
  }
  const dexkit::schema::EncodeValueLong *number_as_EncodeValueLong() const {
    return number_type() == dexkit::schema::Number::EncodeValueLong ? static_cast<const dexkit::schema::EncodeValueLong *>(number()) : nullptr;
  }
  const dexkit::schema::EncodeValueFloat *number_as_EncodeValueFloat() const {
    return number_type() == dexkit::schema::Number::EncodeValueFloat ? static_cast<const dexkit::schema::EncodeValueFloat *>(number()) : nullptr;
  }
  const dexkit::schema::EncodeValueDouble *number_as_EncodeValueDouble() const {
    return number_type() == dexkit::schema::Number::EncodeValueDouble ? static_cast<const dexkit::schema::EncodeValueDouble *>(number()) : nullptr;
  }
  dexkit::schema::UsingType using_type() const {
    return static_cast<dexkit::schema::UsingType>(GetField<int8_t>(VT_USING_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NUMBER_TYPE, 1) &&
           VerifyOffset(verifier, VT_NUMBER) &&
           VerifyNumber(verifier, number(), number_type()) &&
           VerifyField<int8_t>(verifier, VT_USING_TYPE, 1) &&
           verifier.EndTable();
  }
};

template<> inline const dexkit::schema::EncodeValueShort *UsingNumberMatcher::number_as<dexkit::schema::EncodeValueShort>() const {
  return number_as_EncodeValueShort();
}

template<> inline const dexkit::schema::EncodeValueInt *UsingNumberMatcher::number_as<dexkit::schema::EncodeValueInt>() const {
  return number_as_EncodeValueInt();
}

template<> inline const dexkit::schema::EncodeValueLong *UsingNumberMatcher::number_as<dexkit::schema::EncodeValueLong>() const {
  return number_as_EncodeValueLong();
}

template<> inline const dexkit::schema::EncodeValueFloat *UsingNumberMatcher::number_as<dexkit::schema::EncodeValueFloat>() const {
  return number_as_EncodeValueFloat();
}

template<> inline const dexkit::schema::EncodeValueDouble *UsingNumberMatcher::number_as<dexkit::schema::EncodeValueDouble>() const {
  return number_as_EncodeValueDouble();
}

struct UsingNumberMatcherBuilder {
  typedef UsingNumberMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_number_type(dexkit::schema::Number number_type) {
    fbb_.AddElement<uint8_t>(UsingNumberMatcher::VT_NUMBER_TYPE, static_cast<uint8_t>(number_type), 0);
  }
  void add_number(::flatbuffers::Offset<void> number) {
    fbb_.AddOffset(UsingNumberMatcher::VT_NUMBER, number);
  }
  void add_using_type(dexkit::schema::UsingType using_type) {
    fbb_.AddElement<int8_t>(UsingNumberMatcher::VT_USING_TYPE, static_cast<int8_t>(using_type), 0);
  }
  explicit UsingNumberMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingNumberMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingNumberMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingNumberMatcher> CreateUsingNumberMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    dexkit::schema::Number number_type = dexkit::schema::Number::NONE,
    ::flatbuffers::Offset<void> number = 0,
    dexkit::schema::UsingType using_type = dexkit::schema::UsingType::Any) {
  UsingNumberMatcherBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_using_type(using_type);
  builder_.add_number_type(number_type);
  return builder_.Finish();
}

struct UsingNumberMatcher::Traits {
  using type = UsingNumberMatcher;
  static auto constexpr Create = CreateUsingNumberMatcher;
};

struct MethodMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_NAME = 4,
    VT_ACCESS_FLAGS = 6,
    VT_DECLARING_CLASS = 8,
    VT_RETURN_TYPE = 10,
    VT_PARAMETERS = 12,
    VT_ANNOTATIONS = 14,
    VT_OP_CODES = 16,
    VT_USING_STRINGS = 18,
    VT_USING_FIELS = 20,
    VT_USING_NUMBERS = 22,
    VT_INVOKING_METHODS = 24,
    VT_METHOD_CALLERS = 26
  };
  const dexkit::schema::StringMatcher *method_name() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_METHOD_NAME);
  }
  const dexkit::schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const dexkit::schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const dexkit::schema::ClassMatcher *declaring_class() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_DECLARING_CLASS);
  }
  const dexkit::schema::ClassMatcher *return_type() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_RETURN_TYPE);
  }
  const dexkit::schema::ParametersMatcher *parameters() const {
    return GetPointer<const dexkit::schema::ParametersMatcher *>(VT_PARAMETERS);
  }
  const dexkit::schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const dexkit::schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const dexkit::schema::OpCodesMatcher *op_codes() const {
    return GetPointer<const dexkit::schema::OpCodesMatcher *>(VT_OP_CODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>> *using_fiels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>> *>(VT_USING_FIELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>> *using_numbers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>> *>(VT_USING_NUMBERS);
  }
  const dexkit::schema::MethodsMatcher *invoking_methods() const {
    return GetPointer<const dexkit::schema::MethodsMatcher *>(VT_INVOKING_METHODS);
  }
  const dexkit::schema::MethodsMatcher *method_callers() const {
    return GetPointer<const dexkit::schema::MethodsMatcher *>(VT_METHOD_CALLERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD_NAME) &&
           verifier.VerifyTable(method_name()) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyOffset(verifier, VT_RETURN_TYPE) &&
           verifier.VerifyTable(return_type()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyTable(parameters()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_OP_CODES) &&
           verifier.VerifyTable(op_codes()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           VerifyOffset(verifier, VT_USING_FIELS) &&
           verifier.VerifyVector(using_fiels()) &&
           verifier.VerifyVectorOfTables(using_fiels()) &&
           VerifyOffset(verifier, VT_USING_NUMBERS) &&
           verifier.VerifyVector(using_numbers()) &&
           verifier.VerifyVectorOfTables(using_numbers()) &&
           VerifyOffset(verifier, VT_INVOKING_METHODS) &&
           verifier.VerifyTable(invoking_methods()) &&
           VerifyOffset(verifier, VT_METHOD_CALLERS) &&
           verifier.VerifyTable(method_callers()) &&
           verifier.EndTable();
  }
};

struct MethodMatcherBuilder {
  typedef MethodMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method_name(::flatbuffers::Offset<dexkit::schema::StringMatcher> method_name) {
    fbb_.AddOffset(MethodMatcher::VT_METHOD_NAME, method_name);
  }
  void add_access_flags(::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(MethodMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_declaring_class(::flatbuffers::Offset<dexkit::schema::ClassMatcher> declaring_class) {
    fbb_.AddOffset(MethodMatcher::VT_DECLARING_CLASS, declaring_class);
  }
  void add_return_type(::flatbuffers::Offset<dexkit::schema::ClassMatcher> return_type) {
    fbb_.AddOffset(MethodMatcher::VT_RETURN_TYPE, return_type);
  }
  void add_parameters(::flatbuffers::Offset<dexkit::schema::ParametersMatcher> parameters) {
    fbb_.AddOffset(MethodMatcher::VT_PARAMETERS, parameters);
  }
  void add_annotations(::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(MethodMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_op_codes(::flatbuffers::Offset<dexkit::schema::OpCodesMatcher> op_codes) {
    fbb_.AddOffset(MethodMatcher::VT_OP_CODES, op_codes);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(MethodMatcher::VT_USING_STRINGS, using_strings);
  }
  void add_using_fiels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>>> using_fiels) {
    fbb_.AddOffset(MethodMatcher::VT_USING_FIELS, using_fiels);
  }
  void add_using_numbers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>>> using_numbers) {
    fbb_.AddOffset(MethodMatcher::VT_USING_NUMBERS, using_numbers);
  }
  void add_invoking_methods(::flatbuffers::Offset<dexkit::schema::MethodsMatcher> invoking_methods) {
    fbb_.AddOffset(MethodMatcher::VT_INVOKING_METHODS, invoking_methods);
  }
  void add_method_callers(::flatbuffers::Offset<dexkit::schema::MethodsMatcher> method_callers) {
    fbb_.AddOffset(MethodMatcher::VT_METHOD_CALLERS, method_callers);
  }
  explicit MethodMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMatcher> CreateMethodMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> method_name = 0,
    ::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> return_type = 0,
    ::flatbuffers::Offset<dexkit::schema::ParametersMatcher> parameters = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::OpCodesMatcher> op_codes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>>> using_fiels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>>> using_numbers = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> invoking_methods = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> method_callers = 0) {
  MethodMatcherBuilder builder_(_fbb);
  builder_.add_method_callers(method_callers);
  builder_.add_invoking_methods(invoking_methods);
  builder_.add_using_numbers(using_numbers);
  builder_.add_using_fiels(using_fiels);
  builder_.add_using_strings(using_strings);
  builder_.add_op_codes(op_codes);
  builder_.add_annotations(annotations);
  builder_.add_parameters(parameters);
  builder_.add_return_type(return_type);
  builder_.add_declaring_class(declaring_class);
  builder_.add_access_flags(access_flags);
  builder_.add_method_name(method_name);
  return builder_.Finish();
}

struct MethodMatcher::Traits {
  using type = MethodMatcher;
  static auto constexpr Create = CreateMethodMatcher;
};

inline ::flatbuffers::Offset<MethodMatcher> CreateMethodMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> method_name = 0,
    ::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> return_type = 0,
    ::flatbuffers::Offset<dexkit::schema::ParametersMatcher> parameters = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::OpCodesMatcher> op_codes = 0,
    const std::vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>> *using_fiels = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>> *using_numbers = nullptr,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> invoking_methods = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> method_callers = 0) {
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>(*using_strings) : 0;
  auto using_fiels__ = using_fiels ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::UsingFieldMatcher>>(*using_fiels) : 0;
  auto using_numbers__ = using_numbers ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::UsingNumberMatcher>>(*using_numbers) : 0;
  return dexkit::schema::CreateMethodMatcher(
      _fbb,
      method_name,
      access_flags,
      declaring_class,
      return_type,
      parameters,
      annotations,
      op_codes,
      using_strings__,
      using_fiels__,
      using_numbers__,
      invoking_methods,
      method_callers);
}

struct MethodsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHODS = 4,
    VT_MATCH_TYPE = 6,
    VT_METHOD_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>> *>(VT_METHODS);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *method_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_METHOD_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_METHOD_COUNT) &&
           verifier.VerifyTable(method_count()) &&
           verifier.EndTable();
  }
};

struct MethodsMatcherBuilder {
  typedef MethodsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>>> methods) {
    fbb_.AddOffset(MethodsMatcher::VT_METHODS, methods);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(MethodsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_method_count(::flatbuffers::Offset<dexkit::schema::IntRange> method_count) {
    fbb_.AddOffset(MethodsMatcher::VT_METHOD_COUNT, method_count);
  }
  explicit MethodsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodsMatcher> CreateMethodsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>>> methods = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> method_count = 0) {
  MethodsMatcherBuilder builder_(_fbb);
  builder_.add_method_count(method_count);
  builder_.add_methods(methods);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct MethodsMatcher::Traits {
  using type = MethodsMatcher;
  static auto constexpr Create = CreateMethodsMatcher;
};

inline ::flatbuffers::Offset<MethodsMatcher> CreateMethodsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>> *methods = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> method_count = 0) {
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::MethodMatcher>>(*methods) : 0;
  return dexkit::schema::CreateMethodsMatcher(
      _fbb,
      methods__,
      match_type,
      method_count);
}

struct InterfacesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InterfacesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERFACES = 4,
    VT_MATCH_TYPE = 6,
    VT_INTERFACE_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>> *interfaces() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>> *>(VT_INTERFACES);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *interface_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_INTERFACE_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyVector(interfaces()) &&
           verifier.VerifyVectorOfTables(interfaces()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_INTERFACE_COUNT) &&
           verifier.VerifyTable(interface_count()) &&
           verifier.EndTable();
  }
};

struct InterfacesMatcherBuilder {
  typedef InterfacesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_interfaces(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>>> interfaces) {
    fbb_.AddOffset(InterfacesMatcher::VT_INTERFACES, interfaces);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(InterfacesMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_interface_count(::flatbuffers::Offset<dexkit::schema::IntRange> interface_count) {
    fbb_.AddOffset(InterfacesMatcher::VT_INTERFACE_COUNT, interface_count);
  }
  explicit InterfacesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InterfacesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InterfacesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InterfacesMatcher> CreateInterfacesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>>> interfaces = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> interface_count = 0) {
  InterfacesMatcherBuilder builder_(_fbb);
  builder_.add_interface_count(interface_count);
  builder_.add_interfaces(interfaces);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct InterfacesMatcher::Traits {
  using type = InterfacesMatcher;
  static auto constexpr Create = CreateInterfacesMatcher;
};

inline ::flatbuffers::Offset<InterfacesMatcher> CreateInterfacesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>> *interfaces = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> interface_count = 0) {
  auto interfaces__ = interfaces ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::ClassMatcher>>(*interfaces) : 0;
  return dexkit::schema::CreateInterfacesMatcher(
      _fbb,
      interfaces__,
      match_type,
      interface_count);
}

struct FieldMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_NAME = 4,
    VT_ACCESS_FLAGS = 6,
    VT_DECLARING_CLASS = 8,
    VT_TYPE_CLASS = 10,
    VT_ANNOTATIONS = 12,
    VT_GET_METHODS = 14,
    VT_PUT_METHODS = 16
  };
  const dexkit::schema::StringMatcher *field_name() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_FIELD_NAME);
  }
  const dexkit::schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const dexkit::schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const dexkit::schema::ClassMatcher *declaring_class() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_DECLARING_CLASS);
  }
  const dexkit::schema::ClassMatcher *type_class() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_TYPE_CLASS);
  }
  const dexkit::schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const dexkit::schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const dexkit::schema::MethodsMatcher *get_methods() const {
    return GetPointer<const dexkit::schema::MethodsMatcher *>(VT_GET_METHODS);
  }
  const dexkit::schema::MethodsMatcher *put_methods() const {
    return GetPointer<const dexkit::schema::MethodsMatcher *>(VT_PUT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD_NAME) &&
           verifier.VerifyTable(field_name()) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyOffset(verifier, VT_TYPE_CLASS) &&
           verifier.VerifyTable(type_class()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_GET_METHODS) &&
           verifier.VerifyTable(get_methods()) &&
           VerifyOffset(verifier, VT_PUT_METHODS) &&
           verifier.VerifyTable(put_methods()) &&
           verifier.EndTable();
  }
};

struct FieldMatcherBuilder {
  typedef FieldMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_name(::flatbuffers::Offset<dexkit::schema::StringMatcher> field_name) {
    fbb_.AddOffset(FieldMatcher::VT_FIELD_NAME, field_name);
  }
  void add_access_flags(::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(FieldMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_declaring_class(::flatbuffers::Offset<dexkit::schema::ClassMatcher> declaring_class) {
    fbb_.AddOffset(FieldMatcher::VT_DECLARING_CLASS, declaring_class);
  }
  void add_type_class(::flatbuffers::Offset<dexkit::schema::ClassMatcher> type_class) {
    fbb_.AddOffset(FieldMatcher::VT_TYPE_CLASS, type_class);
  }
  void add_annotations(::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(FieldMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_get_methods(::flatbuffers::Offset<dexkit::schema::MethodsMatcher> get_methods) {
    fbb_.AddOffset(FieldMatcher::VT_GET_METHODS, get_methods);
  }
  void add_put_methods(::flatbuffers::Offset<dexkit::schema::MethodsMatcher> put_methods) {
    fbb_.AddOffset(FieldMatcher::VT_PUT_METHODS, put_methods);
  }
  explicit FieldMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMatcher> CreateFieldMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> field_name = 0,
    ::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> type_class = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> get_methods = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> put_methods = 0) {
  FieldMatcherBuilder builder_(_fbb);
  builder_.add_put_methods(put_methods);
  builder_.add_get_methods(get_methods);
  builder_.add_annotations(annotations);
  builder_.add_type_class(type_class);
  builder_.add_declaring_class(declaring_class);
  builder_.add_access_flags(access_flags);
  builder_.add_field_name(field_name);
  return builder_.Finish();
}

struct FieldMatcher::Traits {
  using type = FieldMatcher;
  static auto constexpr Create = CreateFieldMatcher;
};

struct FieldsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAIN_FIELDS = 4,
    VT_MATCH_TYPE = 6,
    VT_FIELD_COUNT = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>> *contain_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>> *>(VT_CONTAIN_FIELDS);
  }
  dexkit::schema::MatchType match_type() const {
    return static_cast<dexkit::schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const dexkit::schema::IntRange *field_count() const {
    return GetPointer<const dexkit::schema::IntRange *>(VT_FIELD_COUNT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAIN_FIELDS) &&
           verifier.VerifyVector(contain_fields()) &&
           verifier.VerifyVectorOfTables(contain_fields()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIELD_COUNT) &&
           verifier.VerifyTable(field_count()) &&
           verifier.EndTable();
  }
};

struct FieldsMatcherBuilder {
  typedef FieldsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_contain_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>>> contain_fields) {
    fbb_.AddOffset(FieldsMatcher::VT_CONTAIN_FIELDS, contain_fields);
  }
  void add_match_type(dexkit::schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(FieldsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_field_count(::flatbuffers::Offset<dexkit::schema::IntRange> field_count) {
    fbb_.AddOffset(FieldsMatcher::VT_FIELD_COUNT, field_count);
  }
  explicit FieldsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldsMatcher> CreateFieldsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>>> contain_fields = 0,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> field_count = 0) {
  FieldsMatcherBuilder builder_(_fbb);
  builder_.add_field_count(field_count);
  builder_.add_contain_fields(contain_fields);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct FieldsMatcher::Traits {
  using type = FieldsMatcher;
  static auto constexpr Create = CreateFieldsMatcher;
};

inline ::flatbuffers::Offset<FieldsMatcher> CreateFieldsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>> *contain_fields = nullptr,
    dexkit::schema::MatchType match_type = dexkit::schema::MatchType::Contain,
    ::flatbuffers::Offset<dexkit::schema::IntRange> field_count = 0) {
  auto contain_fields__ = contain_fields ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::FieldMatcher>>(*contain_fields) : 0;
  return dexkit::schema::CreateFieldsMatcher(
      _fbb,
      contain_fields__,
      match_type,
      field_count);
}

struct ClassMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SMALI_SOURCE = 4,
    VT_CLASS_NAME = 6,
    VT_ACCESS_FLAGS = 8,
    VT_SUPER_CLASS = 10,
    VT_INTERFACES = 12,
    VT_ANNOTATIONS = 14,
    VT_FIELDS = 16,
    VT_METHODS = 18,
    VT_USING_STRINGS = 20
  };
  const dexkit::schema::StringMatcher *smali_source() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_SMALI_SOURCE);
  }
  const dexkit::schema::StringMatcher *class_name() const {
    return GetPointer<const dexkit::schema::StringMatcher *>(VT_CLASS_NAME);
  }
  const dexkit::schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const dexkit::schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const dexkit::schema::ClassMatcher *super_class() const {
    return GetPointer<const dexkit::schema::ClassMatcher *>(VT_SUPER_CLASS);
  }
  const dexkit::schema::InterfacesMatcher *interfaces() const {
    return GetPointer<const dexkit::schema::InterfacesMatcher *>(VT_INTERFACES);
  }
  const dexkit::schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const dexkit::schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const dexkit::schema::FieldsMatcher *fields() const {
    return GetPointer<const dexkit::schema::FieldsMatcher *>(VT_FIELDS);
  }
  const dexkit::schema::MethodsMatcher *methods() const {
    return GetPointer<const dexkit::schema::MethodsMatcher *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SMALI_SOURCE) &&
           verifier.VerifyTable(smali_source()) &&
           VerifyOffset(verifier, VT_CLASS_NAME) &&
           verifier.VerifyTable(class_name()) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_SUPER_CLASS) &&
           verifier.VerifyTable(super_class()) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyTable(interfaces()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyTable(fields()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyTable(methods()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           verifier.EndTable();
  }
};

struct ClassMatcherBuilder {
  typedef ClassMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_smali_source(::flatbuffers::Offset<dexkit::schema::StringMatcher> smali_source) {
    fbb_.AddOffset(ClassMatcher::VT_SMALI_SOURCE, smali_source);
  }
  void add_class_name(::flatbuffers::Offset<dexkit::schema::StringMatcher> class_name) {
    fbb_.AddOffset(ClassMatcher::VT_CLASS_NAME, class_name);
  }
  void add_access_flags(::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(ClassMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_super_class(::flatbuffers::Offset<dexkit::schema::ClassMatcher> super_class) {
    fbb_.AddOffset(ClassMatcher::VT_SUPER_CLASS, super_class);
  }
  void add_interfaces(::flatbuffers::Offset<dexkit::schema::InterfacesMatcher> interfaces) {
    fbb_.AddOffset(ClassMatcher::VT_INTERFACES, interfaces);
  }
  void add_annotations(::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(ClassMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_fields(::flatbuffers::Offset<dexkit::schema::FieldsMatcher> fields) {
    fbb_.AddOffset(ClassMatcher::VT_FIELDS, fields);
  }
  void add_methods(::flatbuffers::Offset<dexkit::schema::MethodsMatcher> methods) {
    fbb_.AddOffset(ClassMatcher::VT_METHODS, methods);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(ClassMatcher::VT_USING_STRINGS, using_strings);
  }
  explicit ClassMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMatcher> CreateClassMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> smali_source = 0,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> class_name = 0,
    ::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> super_class = 0,
    ::flatbuffers::Offset<dexkit::schema::InterfacesMatcher> interfaces = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::FieldsMatcher> fields = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings = 0) {
  ClassMatcherBuilder builder_(_fbb);
  builder_.add_using_strings(using_strings);
  builder_.add_methods(methods);
  builder_.add_fields(fields);
  builder_.add_annotations(annotations);
  builder_.add_interfaces(interfaces);
  builder_.add_super_class(super_class);
  builder_.add_access_flags(access_flags);
  builder_.add_class_name(class_name);
  builder_.add_smali_source(smali_source);
  return builder_.Finish();
}

struct ClassMatcher::Traits {
  using type = ClassMatcher;
  static auto constexpr Create = CreateClassMatcher;
};

inline ::flatbuffers::Offset<ClassMatcher> CreateClassMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> smali_source = 0,
    ::flatbuffers::Offset<dexkit::schema::StringMatcher> class_name = 0,
    ::flatbuffers::Offset<dexkit::schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<dexkit::schema::ClassMatcher> super_class = 0,
    ::flatbuffers::Offset<dexkit::schema::InterfacesMatcher> interfaces = 0,
    ::flatbuffers::Offset<dexkit::schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<dexkit::schema::FieldsMatcher> fields = 0,
    ::flatbuffers::Offset<dexkit::schema::MethodsMatcher> methods = 0,
    const std::vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings = nullptr) {
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>(*using_strings) : 0;
  return dexkit::schema::CreateClassMatcher(
      _fbb,
      smali_source,
      class_name,
      access_flags,
      super_class,
      interfaces,
      annotations,
      fields,
      methods,
      using_strings__);
}

struct BatchUsingStringsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchUsingStringsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_KEY = 4,
    VT_USING_STRINGS = 6
  };
  const ::flatbuffers::String *union_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_KEY) &&
           verifier.VerifyString(union_key()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           verifier.EndTable();
  }
};

struct BatchUsingStringsMatcherBuilder {
  typedef BatchUsingStringsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_key(::flatbuffers::Offset<::flatbuffers::String> union_key) {
    fbb_.AddOffset(BatchUsingStringsMatcher::VT_UNION_KEY, union_key);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(BatchUsingStringsMatcher::VT_USING_STRINGS, using_strings);
  }
  explicit BatchUsingStringsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchUsingStringsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchUsingStringsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchUsingStringsMatcher> CreateBatchUsingStringsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>> using_strings = 0) {
  BatchUsingStringsMatcherBuilder builder_(_fbb);
  builder_.add_using_strings(using_strings);
  builder_.add_union_key(union_key);
  return builder_.Finish();
}

struct BatchUsingStringsMatcher::Traits {
  using type = BatchUsingStringsMatcher;
  static auto constexpr Create = CreateBatchUsingStringsMatcher;
};

inline ::flatbuffers::Offset<BatchUsingStringsMatcher> CreateBatchUsingStringsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_key = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::StringMatcher>> *using_strings = nullptr) {
  auto union_key__ = union_key ? _fbb.CreateString(union_key) : 0;
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::StringMatcher>>(*using_strings) : 0;
  return dexkit::schema::CreateBatchUsingStringsMatcher(
      _fbb,
      union_key__,
      using_strings__);
}

inline bool VerifyAnnotationEncodeValueMatcher(::flatbuffers::Verifier &verifier, const void *obj, AnnotationEncodeValueMatcher type) {
  switch (type) {
    case AnnotationEncodeValueMatcher::NONE: {
      return true;
    }
    case AnnotationEncodeValueMatcher::EncodeValueBoolean: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueByte: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueShort: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueChar: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueInt: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueLong: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::StringMatcher: {
      auto ptr = reinterpret_cast<const dexkit::schema::StringMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::ClassMatcher: {
      auto ptr = reinterpret_cast<const dexkit::schema::ClassMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::FieldMatcher: {
      auto ptr = reinterpret_cast<const dexkit::schema::FieldMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::AnnotationEncodeArrayMatcher: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationEncodeArrayMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationEncodeValueMatcher::AnnotationMatcher: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnnotationEncodeValueMatcherVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationEncodeValueMatcher> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnnotationEncodeValueMatcher(
        verifier,  values->Get(i), types->GetEnum<AnnotationEncodeValueMatcher>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyNumber(::flatbuffers::Verifier &verifier, const void *obj, Number type) {
  switch (type) {
    case Number::NONE: {
      return true;
    }
    case Number::EncodeValueShort: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueInt: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueLong: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNumberVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Number> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNumber(
        verifier,  values->Get(i), types->GetEnum<Number>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema
}  // namespace dexkit

#endif  // FLATBUFFERS_GENERATED_MATCHERS_DEXKIT_SCHEMA_H_
