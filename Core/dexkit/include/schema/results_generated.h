// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_
#define FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "encode_value_generated.h"
#include "enums_generated.h"

namespace dexkit {
namespace schema {

struct ClassMeta;
struct ClassMetaBuilder;

struct MethodMeta;
struct MethodMetaBuilder;

struct FieldMeta;
struct FieldMetaBuilder;

struct EnumValueMeta;
struct EnumValueMetaBuilder;

struct AnnotationElementValueArray;
struct AnnotationElementValueArrayBuilder;

struct AnnotationMemberMeta;
struct AnnotationMemberMetaBuilder;

struct AnnotationMeta;
struct AnnotationMetaBuilder;

struct BatchFindClassItem;
struct BatchFindClassItemBuilder;

struct BatchFindMethodItem;
struct BatchFindMethodItemBuilder;

enum class AnnotationElementValue : uint8_t {
  NONE = 0,
  EncodeValueByte = 1,
  EncodeValueShort = 2,
  EncodeValueChar = 3,
  EncodeValueInt = 4,
  EncodeValueLong = 5,
  EncodeValueFloat = 6,
  EncodeValueDouble = 7,
  EncodeValueString = 8,
  ClassMeta = 9,
  EnumValueMeta = 10,
  AnnotationElementValueArray = 11,
  AnnotationMeta = 12,
  EncodeValueBoolean = 13
};

inline const AnnotationElementValue (&EnumValuesAnnotationElementValue())[14] {
  static const AnnotationElementValue values[] = {
    AnnotationElementValue::NONE,
    AnnotationElementValue::EncodeValueByte,
    AnnotationElementValue::EncodeValueShort,
    AnnotationElementValue::EncodeValueChar,
    AnnotationElementValue::EncodeValueInt,
    AnnotationElementValue::EncodeValueLong,
    AnnotationElementValue::EncodeValueFloat,
    AnnotationElementValue::EncodeValueDouble,
    AnnotationElementValue::EncodeValueString,
    AnnotationElementValue::ClassMeta,
    AnnotationElementValue::EnumValueMeta,
    AnnotationElementValue::AnnotationElementValueArray,
    AnnotationElementValue::AnnotationMeta,
    AnnotationElementValue::EncodeValueBoolean
  };
  return values;
}

inline const char * const *EnumNamesAnnotationElementValue() {
  static const char * const names[15] = {
    "NONE",
    "EncodeValueByte",
    "EncodeValueShort",
    "EncodeValueChar",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    "EncodeValueString",
    "ClassMeta",
    "EnumValueMeta",
    "AnnotationElementValueArray",
    "AnnotationMeta",
    "EncodeValueBoolean",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationElementValue(AnnotationElementValue e) {
  if (::flatbuffers::IsOutRange(e, AnnotationElementValue::NONE, AnnotationElementValue::EncodeValueBoolean)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationElementValue()[index];
}

template<typename T> struct AnnotationElementValueTraits {
  static const AnnotationElementValue enum_value = AnnotationElementValue::NONE;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueByte> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueByte;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueShort> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueShort;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueChar> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueChar;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueInt> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueInt;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueLong> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueLong;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueFloat> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueFloat;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueDouble> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueDouble;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueString> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueString;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::ClassMeta> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::ClassMeta;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EnumValueMeta> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EnumValueMeta;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::AnnotationElementValueArray> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::AnnotationElementValueArray;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::AnnotationMeta> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::AnnotationMeta;
};

template<> struct AnnotationElementValueTraits<dexkit::schema::EncodeValueBoolean> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueBoolean;
};

bool VerifyAnnotationElementValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValue type);
bool VerifyAnnotationElementValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValue> *types);

struct ClassMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_SOURCE_FILE = 8,
    VT_ANNOTATIONS = 10,
    VT_ACCESS_FLAGS = 12,
    VT_DEX_DESCRIPTOR = 14,
    VT_SUPER_CLASS = 16,
    VT_INTERFACES = 18,
    VT_FIELDS = 20,
    VT_METHODS = 22
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::String *source_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FILE);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t super_class() const {
    return GetField<int32_t>(VT_SUPER_CLASS, 0);
  }
  const ::flatbuffers::Vector<int32_t> *interfaces() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERFACES);
  }
  const ::flatbuffers::Vector<int32_t> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_FIELDS);
  }
  const ::flatbuffers::Vector<int32_t> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_SOURCE_FILE) &&
           verifier.VerifyString(source_file()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_SUPER_CLASS, 4) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyVector(interfaces()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.EndTable();
  }
};

struct ClassMetaBuilder {
  typedef ClassMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_source_file(::flatbuffers::Offset<::flatbuffers::String> source_file) {
    fbb_.AddOffset(ClassMeta::VT_SOURCE_FILE, source_file);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(ClassMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(ClassMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_super_class(int32_t super_class) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_SUPER_CLASS, super_class, 0);
  }
  void add_interfaces(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces) {
    fbb_.AddOffset(ClassMeta::VT_INTERFACES, interfaces);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields) {
    fbb_.AddOffset(ClassMeta::VT_FIELDS, fields);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods) {
    fbb_.AddOffset(ClassMeta::VT_METHODS, methods);
  }
  explicit ClassMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_file = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t super_class = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods = 0) {
  ClassMetaBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_fields(fields);
  builder_.add_interfaces(interfaces);
  builder_.add_super_class(super_class);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_source_file(source_file);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ClassMeta::Traits {
  using type = ClassMeta;
  static auto constexpr Create = CreateClassMeta;
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    const char *source_file = nullptr,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t super_class = 0,
    const std::vector<int32_t> *interfaces = nullptr,
    const std::vector<int32_t> *fields = nullptr,
    const std::vector<int32_t> *methods = nullptr) {
  auto source_file__ = source_file ? _fbb.CreateString(source_file) : 0;
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto interfaces__ = interfaces ? _fbb.CreateVector<int32_t>(*interfaces) : 0;
  auto fields__ = fields ? _fbb.CreateVector<int32_t>(*fields) : 0;
  auto methods__ = methods ? _fbb.CreateVector<int32_t>(*methods) : 0;
  return dexkit::schema::CreateClassMeta(
      _fbb,
      id,
      dex_id,
      source_file__,
      annotations__,
      access_flags,
      dex_descriptor__,
      super_class,
      interfaces__,
      fields__,
      methods__);
}

struct MethodMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_ANNOTATIONS = 10,
    VT_ACCESS_FLAGS = 12,
    VT_DEX_DESCRIPTOR = 14,
    VT_RETURN_TYPE = 16,
    VT_PARAMETER_TYPES = 18
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  int32_t class_id() const {
    return GetField<int32_t>(VT_CLASS_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t return_type() const {
    return GetField<int32_t>(VT_RETURN_TYPE, 0);
  }
  const ::flatbuffers::Vector<int32_t> *parameter_types() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMETER_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_RETURN_TYPE, 4) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPES) &&
           verifier.VerifyVector(parameter_types()) &&
           verifier.EndTable();
  }
};

struct MethodMetaBuilder {
  typedef MethodMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(int32_t class_id) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(MethodMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(MethodMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_return_type(int32_t return_type) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_RETURN_TYPE, return_type, 0);
  }
  void add_parameter_types(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types) {
    fbb_.AddOffset(MethodMeta::VT_PARAMETER_TYPES, parameter_types);
  }
  explicit MethodMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t return_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types = 0) {
  MethodMetaBuilder builder_(_fbb);
  builder_.add_parameter_types(parameter_types);
  builder_.add_return_type(return_type);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodMeta::Traits {
  using type = MethodMeta;
  static auto constexpr Create = CreateMethodMeta;
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t return_type = 0,
    const std::vector<int32_t> *parameter_types = nullptr) {
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto parameter_types__ = parameter_types ? _fbb.CreateVector<int32_t>(*parameter_types) : 0;
  return dexkit::schema::CreateMethodMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      annotations__,
      access_flags,
      dex_descriptor__,
      return_type,
      parameter_types__);
}

struct FieldMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_ANNOTATIONS = 10,
    VT_ACCESS_FLAGS = 12,
    VT_DEX_DESCRIPTOR = 14,
    VT_TYPE = 16
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  int32_t class_id() const {
    return GetField<int32_t>(VT_CLASS_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct FieldMetaBuilder {
  typedef FieldMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(int32_t class_id) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(FieldMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(FieldMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_TYPE, type, 0);
  }
  explicit FieldMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t type = 0) {
  FieldMetaBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct FieldMeta::Traits {
  using type = FieldMeta;
  static auto constexpr Create = CreateFieldMeta;
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t type = 0) {
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  return dexkit::schema::CreateFieldMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      annotations__,
      access_flags,
      dex_descriptor__,
      type);
}

struct EnumValueMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EnumValueMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_VALUE_NAME = 10
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  int32_t class_id() const {
    return GetField<int32_t>(VT_CLASS_ID, 0);
  }
  const ::flatbuffers::String *value_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyOffset(verifier, VT_VALUE_NAME) &&
           verifier.VerifyString(value_name()) &&
           verifier.EndTable();
  }
};

struct EnumValueMetaBuilder {
  typedef EnumValueMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(EnumValueMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(EnumValueMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(int32_t class_id) {
    fbb_.AddElement<int32_t>(EnumValueMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_value_name(::flatbuffers::Offset<::flatbuffers::String> value_name) {
    fbb_.AddOffset(EnumValueMeta::VT_VALUE_NAME, value_name);
  }
  explicit EnumValueMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EnumValueMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EnumValueMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EnumValueMeta> CreateEnumValueMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value_name = 0) {
  EnumValueMetaBuilder builder_(_fbb);
  builder_.add_value_name(value_name);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct EnumValueMeta::Traits {
  using type = EnumValueMeta;
  static auto constexpr Create = CreateEnumValueMeta;
};

inline ::flatbuffers::Offset<EnumValueMeta> CreateEnumValueMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    const char *value_name = nullptr) {
  auto value_name__ = value_name ? _fbb.CreateString(value_name) : 0;
  return dexkit::schema::CreateEnumValueMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      value_name__);
}

struct AnnotationElementValueArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementValueArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_TYPE = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<dexkit::schema::AnnotationElementValue> *values_type() const {
    return GetPointer<const ::flatbuffers::Vector<dexkit::schema::AnnotationElementValue> *>(VT_VALUES_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES_TYPE) &&
           verifier.VerifyVector(values_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyAnnotationElementValueVector(verifier, values(), values_type()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementValueArrayBuilder {
  typedef AnnotationElementValueArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values_type(::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::AnnotationElementValue>> values_type) {
    fbb_.AddOffset(AnnotationElementValueArray::VT_VALUES_TYPE, values_type);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> values) {
    fbb_.AddOffset(AnnotationElementValueArray::VT_VALUES, values);
  }
  explicit AnnotationElementValueArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementValueArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementValueArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementValueArray> CreateAnnotationElementValueArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::AnnotationElementValue>> values_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> values = 0) {
  AnnotationElementValueArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  return builder_.Finish();
}

struct AnnotationElementValueArray::Traits {
  using type = AnnotationElementValueArray;
  static auto constexpr Create = CreateAnnotationElementValueArray;
};

inline ::flatbuffers::Offset<AnnotationElementValueArray> CreateAnnotationElementValueArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<dexkit::schema::AnnotationElementValue> *values_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *values = nullptr) {
  auto values_type__ = values_type ? _fbb.CreateVector<dexkit::schema::AnnotationElementValue>(*values_type) : 0;
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*values) : 0;
  return dexkit::schema::CreateAnnotationElementValueArray(
      _fbb,
      values_type__,
      values__);
}

struct AnnotationMemberMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMemberMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  dexkit::schema::AnnotationElementValue value_type() const {
    return static_cast<dexkit::schema::AnnotationElementValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const dexkit::schema::EncodeValueByte *value_as_EncodeValueByte() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueByte ? static_cast<const dexkit::schema::EncodeValueByte *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueShort *value_as_EncodeValueShort() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueShort ? static_cast<const dexkit::schema::EncodeValueShort *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueChar *value_as_EncodeValueChar() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueChar ? static_cast<const dexkit::schema::EncodeValueChar *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueInt *value_as_EncodeValueInt() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueInt ? static_cast<const dexkit::schema::EncodeValueInt *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueLong *value_as_EncodeValueLong() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueLong ? static_cast<const dexkit::schema::EncodeValueLong *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueFloat *value_as_EncodeValueFloat() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueFloat ? static_cast<const dexkit::schema::EncodeValueFloat *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueDouble *value_as_EncodeValueDouble() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueDouble ? static_cast<const dexkit::schema::EncodeValueDouble *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueString *value_as_EncodeValueString() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueString ? static_cast<const dexkit::schema::EncodeValueString *>(value()) : nullptr;
  }
  const dexkit::schema::ClassMeta *value_as_ClassMeta() const {
    return value_type() == dexkit::schema::AnnotationElementValue::ClassMeta ? static_cast<const dexkit::schema::ClassMeta *>(value()) : nullptr;
  }
  const dexkit::schema::EnumValueMeta *value_as_EnumValueMeta() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EnumValueMeta ? static_cast<const dexkit::schema::EnumValueMeta *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationElementValueArray *value_as_AnnotationElementValueArray() const {
    return value_type() == dexkit::schema::AnnotationElementValue::AnnotationElementValueArray ? static_cast<const dexkit::schema::AnnotationElementValueArray *>(value()) : nullptr;
  }
  const dexkit::schema::AnnotationMeta *value_as_AnnotationMeta() const {
    return value_type() == dexkit::schema::AnnotationElementValue::AnnotationMeta ? static_cast<const dexkit::schema::AnnotationMeta *>(value()) : nullptr;
  }
  const dexkit::schema::EncodeValueBoolean *value_as_EncodeValueBoolean() const {
    return value_type() == dexkit::schema::AnnotationElementValue::EncodeValueBoolean ? static_cast<const dexkit::schema::EncodeValueBoolean *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnnotationElementValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const dexkit::schema::EncodeValueByte *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueByte>() const {
  return value_as_EncodeValueByte();
}

template<> inline const dexkit::schema::EncodeValueShort *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueShort>() const {
  return value_as_EncodeValueShort();
}

template<> inline const dexkit::schema::EncodeValueChar *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueChar>() const {
  return value_as_EncodeValueChar();
}

template<> inline const dexkit::schema::EncodeValueInt *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueInt>() const {
  return value_as_EncodeValueInt();
}

template<> inline const dexkit::schema::EncodeValueLong *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueLong>() const {
  return value_as_EncodeValueLong();
}

template<> inline const dexkit::schema::EncodeValueFloat *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueFloat>() const {
  return value_as_EncodeValueFloat();
}

template<> inline const dexkit::schema::EncodeValueDouble *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueDouble>() const {
  return value_as_EncodeValueDouble();
}

template<> inline const dexkit::schema::EncodeValueString *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueString>() const {
  return value_as_EncodeValueString();
}

template<> inline const dexkit::schema::ClassMeta *AnnotationMemberMeta::value_as<dexkit::schema::ClassMeta>() const {
  return value_as_ClassMeta();
}

template<> inline const dexkit::schema::EnumValueMeta *AnnotationMemberMeta::value_as<dexkit::schema::EnumValueMeta>() const {
  return value_as_EnumValueMeta();
}

template<> inline const dexkit::schema::AnnotationElementValueArray *AnnotationMemberMeta::value_as<dexkit::schema::AnnotationElementValueArray>() const {
  return value_as_AnnotationElementValueArray();
}

template<> inline const dexkit::schema::AnnotationMeta *AnnotationMemberMeta::value_as<dexkit::schema::AnnotationMeta>() const {
  return value_as_AnnotationMeta();
}

template<> inline const dexkit::schema::EncodeValueBoolean *AnnotationMemberMeta::value_as<dexkit::schema::EncodeValueBoolean>() const {
  return value_as_EncodeValueBoolean();
}

struct AnnotationMemberMetaBuilder {
  typedef AnnotationMemberMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnnotationMemberMeta::VT_NAME, name);
  }
  void add_value_type(dexkit::schema::AnnotationElementValue value_type) {
    fbb_.AddElement<uint8_t>(AnnotationMemberMeta::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(AnnotationMemberMeta::VT_VALUE, value);
  }
  explicit AnnotationMemberMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMemberMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMemberMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMemberMeta> CreateAnnotationMemberMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    dexkit::schema::AnnotationElementValue value_type = dexkit::schema::AnnotationElementValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  AnnotationMemberMetaBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct AnnotationMemberMeta::Traits {
  using type = AnnotationMemberMeta;
  static auto constexpr Create = CreateAnnotationMemberMeta;
};

inline ::flatbuffers::Offset<AnnotationMemberMeta> CreateAnnotationMemberMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    dexkit::schema::AnnotationElementValue value_type = dexkit::schema::AnnotationElementValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return dexkit::schema::CreateAnnotationMemberMeta(
      _fbb,
      name__,
      value_type,
      value);
}

struct AnnotationMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_CLASS_ID = 8,
    VT_TARGET_ELEMENT_TYPES = 10,
    VT_RETENTION_POLICY = 12,
    VT_MEMBERS = 14
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  int32_t class_id() const {
    return GetField<int32_t>(VT_CLASS_ID, 0);
  }
  const ::flatbuffers::Vector<dexkit::schema::TargetElementType> *target_element_types() const {
    return GetPointer<const ::flatbuffers::Vector<dexkit::schema::TargetElementType> *>(VT_TARGET_ELEMENT_TYPES);
  }
  dexkit::schema::RetentionPolicyType retention_policy() const {
    return static_cast<dexkit::schema::RetentionPolicyType>(GetField<int8_t>(VT_RETENTION_POLICY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>> *members() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>> *>(VT_MEMBERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_CLASS_ID, 4) &&
           VerifyOffset(verifier, VT_TARGET_ELEMENT_TYPES) &&
           verifier.VerifyVector(target_element_types()) &&
           VerifyField<int8_t>(verifier, VT_RETENTION_POLICY, 1) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
};

struct AnnotationMetaBuilder {
  typedef AnnotationMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(AnnotationMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(AnnotationMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_class_id(int32_t class_id) {
    fbb_.AddElement<int32_t>(AnnotationMeta::VT_CLASS_ID, class_id, 0);
  }
  void add_target_element_types(::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::TargetElementType>> target_element_types) {
    fbb_.AddOffset(AnnotationMeta::VT_TARGET_ELEMENT_TYPES, target_element_types);
  }
  void add_retention_policy(dexkit::schema::RetentionPolicyType retention_policy) {
    fbb_.AddElement<int8_t>(AnnotationMeta::VT_RETENTION_POLICY, static_cast<int8_t>(retention_policy), 0);
  }
  void add_members(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>>> members) {
    fbb_.AddOffset(AnnotationMeta::VT_MEMBERS, members);
  }
  explicit AnnotationMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<dexkit::schema::TargetElementType>> target_element_types = 0,
    dexkit::schema::RetentionPolicyType retention_policy = dexkit::schema::RetentionPolicyType::Source,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>>> members = 0) {
  AnnotationMetaBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_target_element_types(target_element_types);
  builder_.add_class_id(class_id);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  builder_.add_retention_policy(retention_policy);
  return builder_.Finish();
}

struct AnnotationMeta::Traits {
  using type = AnnotationMeta;
  static auto constexpr Create = CreateAnnotationMeta;
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    int32_t class_id = 0,
    const std::vector<dexkit::schema::TargetElementType> *target_element_types = nullptr,
    dexkit::schema::RetentionPolicyType retention_policy = dexkit::schema::RetentionPolicyType::Source,
    const std::vector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>> *members = nullptr) {
  auto target_element_types__ = target_element_types ? _fbb.CreateVector<dexkit::schema::TargetElementType>(*target_element_types) : 0;
  auto members__ = members ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::AnnotationMemberMeta>>(*members) : 0;
  return dexkit::schema::CreateAnnotationMeta(
      _fbb,
      id,
      dex_id,
      class_id,
      target_element_types__,
      retention_policy,
      members__);
}

struct BatchFindClassItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchFindClassItemBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_KEY = 4,
    VT_CLASSES = 6
  };
  const ::flatbuffers::String *union_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *>(VT_CLASSES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_KEY) &&
           verifier.VerifyString(union_key()) &&
           VerifyOffset(verifier, VT_CLASSES) &&
           verifier.VerifyVector(classes()) &&
           verifier.VerifyVectorOfTables(classes()) &&
           verifier.EndTable();
  }
};

struct BatchFindClassItemBuilder {
  typedef BatchFindClassItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_key(::flatbuffers::Offset<::flatbuffers::String> union_key) {
    fbb_.AddOffset(BatchFindClassItem::VT_UNION_KEY, union_key);
  }
  void add_classes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes) {
    fbb_.AddOffset(BatchFindClassItem::VT_CLASSES, classes);
  }
  explicit BatchFindClassItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchFindClassItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchFindClassItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchFindClassItem> CreateBatchFindClassItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>> classes = 0) {
  BatchFindClassItemBuilder builder_(_fbb);
  builder_.add_classes(classes);
  builder_.add_union_key(union_key);
  return builder_.Finish();
}

struct BatchFindClassItem::Traits {
  using type = BatchFindClassItem;
  static auto constexpr Create = CreateBatchFindClassItem;
};

inline ::flatbuffers::Offset<BatchFindClassItem> CreateBatchFindClassItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_key = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::ClassMeta>> *classes = nullptr) {
  auto union_key__ = union_key ? _fbb.CreateString(union_key) : 0;
  auto classes__ = classes ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::ClassMeta>>(*classes) : 0;
  return dexkit::schema::CreateBatchFindClassItem(
      _fbb,
      union_key__,
      classes__);
}

struct BatchFindMethodItem FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchFindMethodItemBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_KEY = 4,
    VT_METHODS = 6
  };
  const ::flatbuffers::String *union_key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_KEY);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *>(VT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_KEY) &&
           verifier.VerifyString(union_key()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.VerifyVectorOfTables(methods()) &&
           verifier.EndTable();
  }
};

struct BatchFindMethodItemBuilder {
  typedef BatchFindMethodItem Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_key(::flatbuffers::Offset<::flatbuffers::String> union_key) {
    fbb_.AddOffset(BatchFindMethodItem::VT_UNION_KEY, union_key);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods) {
    fbb_.AddOffset(BatchFindMethodItem::VT_METHODS, methods);
  }
  explicit BatchFindMethodItemBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchFindMethodItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchFindMethodItem>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchFindMethodItem> CreateBatchFindMethodItem(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_key = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>> methods = 0) {
  BatchFindMethodItemBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_union_key(union_key);
  return builder_.Finish();
}

struct BatchFindMethodItem::Traits {
  using type = BatchFindMethodItem;
  static auto constexpr Create = CreateBatchFindMethodItem;
};

inline ::flatbuffers::Offset<BatchFindMethodItem> CreateBatchFindMethodItemDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_key = nullptr,
    const std::vector<::flatbuffers::Offset<dexkit::schema::MethodMeta>> *methods = nullptr) {
  auto union_key__ = union_key ? _fbb.CreateString(union_key) : 0;
  auto methods__ = methods ? _fbb.CreateVector<::flatbuffers::Offset<dexkit::schema::MethodMeta>>(*methods) : 0;
  return dexkit::schema::CreateBatchFindMethodItem(
      _fbb,
      union_key__,
      methods__);
}

inline bool VerifyAnnotationElementValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValue type) {
  switch (type) {
    case AnnotationElementValue::NONE: {
      return true;
    }
    case AnnotationElementValue::EncodeValueByte: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueShort: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueChar: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueInt: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueLong: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueString: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::ClassMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::ClassMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EnumValueMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::EnumValueMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::AnnotationElementValueArray: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationElementValueArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::AnnotationMeta: {
      auto ptr = reinterpret_cast<const dexkit::schema::AnnotationMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueBoolean: {
      auto ptr = reinterpret_cast<const dexkit::schema::EncodeValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnnotationElementValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnnotationElementValue(
        verifier,  values->Get(i), types->GetEnum<AnnotationElementValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema
}  // namespace dexkit

#endif  // FLATBUFFERS_GENERATED_RESULTS_DEXKIT_SCHEMA_H_
