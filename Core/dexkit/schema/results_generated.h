// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RESULTS_SCHEMA_H_
#define FLATBUFFERS_GENERATED_RESULTS_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "encode_value_generated.h"
#include "enums_generated.h"

namespace schema {

struct ClassMeta;
struct ClassMetaBuilder;

struct MethodMeta;
struct MethodMetaBuilder;

struct FieldMeta;
struct FieldMetaBuilder;

struct AnnotationElementValueArray;
struct AnnotationElementValueArrayBuilder;

struct AnnotationMember;
struct AnnotationMemberBuilder;

struct AnnotationMeta;
struct AnnotationMetaBuilder;

enum class AnnotationElementValue : uint8_t {
  NONE = 0,
  EncodeValueBoolean = 1,
  EncodeValueByte = 2,
  EncodeValueShort = 3,
  EncodeValueChar = 4,
  EncodeValueInt = 5,
  EncodeValueLong = 6,
  EncodeValueFloat = 7,
  EncodeValueDouble = 8,
  EncodeValueString = 9,
  ClassMeta = 10,
  AnnotationElementValueArray = 11,
  AnnotationMeta = 12,
  MIN = NONE,
  MAX = AnnotationMeta
};

inline const AnnotationElementValue (&EnumValuesAnnotationElementValue())[13] {
  static const AnnotationElementValue values[] = {
    AnnotationElementValue::NONE,
    AnnotationElementValue::EncodeValueBoolean,
    AnnotationElementValue::EncodeValueByte,
    AnnotationElementValue::EncodeValueShort,
    AnnotationElementValue::EncodeValueChar,
    AnnotationElementValue::EncodeValueInt,
    AnnotationElementValue::EncodeValueLong,
    AnnotationElementValue::EncodeValueFloat,
    AnnotationElementValue::EncodeValueDouble,
    AnnotationElementValue::EncodeValueString,
    AnnotationElementValue::ClassMeta,
    AnnotationElementValue::AnnotationElementValueArray,
    AnnotationElementValue::AnnotationMeta
  };
  return values;
}

inline const char * const *EnumNamesAnnotationElementValue() {
  static const char * const names[14] = {
    "NONE",
    "EncodeValueBoolean",
    "EncodeValueByte",
    "EncodeValueShort",
    "EncodeValueChar",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    "EncodeValueString",
    "ClassMeta",
    "AnnotationElementValueArray",
    "AnnotationMeta",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationElementValue(AnnotationElementValue e) {
  if (::flatbuffers::IsOutRange(e, AnnotationElementValue::NONE, AnnotationElementValue::AnnotationMeta)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationElementValue()[index];
}

template<typename T> struct AnnotationElementValueTraits {
  static const AnnotationElementValue enum_value = AnnotationElementValue::NONE;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueBoolean> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueBoolean;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueByte> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueByte;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueShort> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueShort;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueChar> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueChar;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueInt> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueInt;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueLong> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueLong;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueFloat> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueFloat;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueDouble> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueDouble;
};

template<> struct AnnotationElementValueTraits<schema::EncodeValueString> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::EncodeValueString;
};

template<> struct AnnotationElementValueTraits<schema::ClassMeta> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::ClassMeta;
};

template<> struct AnnotationElementValueTraits<schema::AnnotationElementValueArray> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::AnnotationElementValueArray;
};

template<> struct AnnotationElementValueTraits<schema::AnnotationMeta> {
  static const AnnotationElementValue enum_value = AnnotationElementValue::AnnotationMeta;
};

bool VerifyAnnotationElementValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValue type);
bool VerifyAnnotationElementValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValue> *types);

struct ClassMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_ANNOTATIONS = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_SUPER_CLASS = 14,
    VT_INTERFACES = 16,
    VT_SOURCE_FILE = 18,
    VT_FIELDS = 20,
    VT_METHODS = 22
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t super_class() const {
    return GetField<int32_t>(VT_SUPER_CLASS, 0);
  }
  const ::flatbuffers::Vector<int32_t> *interfaces() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INTERFACES);
  }
  const ::flatbuffers::String *source_file() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_FILE);
  }
  const ::flatbuffers::Vector<int32_t> *fields() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_FIELDS);
  }
  const ::flatbuffers::Vector<int32_t> *methods() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_SUPER_CLASS, 4) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyVector(interfaces()) &&
           VerifyOffset(verifier, VT_SOURCE_FILE) &&
           verifier.VerifyString(source_file()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyVector(fields()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyVector(methods()) &&
           verifier.EndTable();
  }
};

struct ClassMetaBuilder {
  typedef ClassMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(ClassMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(ClassMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(ClassMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_super_class(int32_t super_class) {
    fbb_.AddElement<int32_t>(ClassMeta::VT_SUPER_CLASS, super_class, 0);
  }
  void add_interfaces(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces) {
    fbb_.AddOffset(ClassMeta::VT_INTERFACES, interfaces);
  }
  void add_source_file(::flatbuffers::Offset<::flatbuffers::String> source_file) {
    fbb_.AddOffset(ClassMeta::VT_SOURCE_FILE, source_file);
  }
  void add_fields(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields) {
    fbb_.AddOffset(ClassMeta::VT_FIELDS, fields);
  }
  void add_methods(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods) {
    fbb_.AddOffset(ClassMeta::VT_METHODS, methods);
  }
  explicit ClassMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t super_class = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> interfaces = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_file = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> fields = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> methods = 0) {
  ClassMetaBuilder builder_(_fbb);
  builder_.add_methods(methods);
  builder_.add_fields(fields);
  builder_.add_source_file(source_file);
  builder_.add_interfaces(interfaces);
  builder_.add_super_class(super_class);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct ClassMeta::Traits {
  using type = ClassMeta;
  static auto constexpr Create = CreateClassMeta;
};

inline ::flatbuffers::Offset<ClassMeta> CreateClassMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t super_class = 0,
    const std::vector<int32_t> *interfaces = nullptr,
    const char *source_file = nullptr,
    const std::vector<int32_t> *fields = nullptr,
    const std::vector<int32_t> *methods = nullptr) {
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto interfaces__ = interfaces ? _fbb.CreateVector<int32_t>(*interfaces) : 0;
  auto source_file__ = source_file ? _fbb.CreateString(source_file) : 0;
  auto fields__ = fields ? _fbb.CreateVector<int32_t>(*fields) : 0;
  auto methods__ = methods ? _fbb.CreateVector<int32_t>(*methods) : 0;
  return schema::CreateClassMeta(
      _fbb,
      id,
      dex_id,
      annotations__,
      access_flags,
      dex_descriptor__,
      super_class,
      interfaces__,
      source_file__,
      fields__,
      methods__);
}

struct MethodMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_ANNOTATIONS = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_RETURN_TYPE = 14,
    VT_PARAMETER_TYPES = 16
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t return_type() const {
    return GetField<int32_t>(VT_RETURN_TYPE, 0);
  }
  const ::flatbuffers::Vector<int32_t> *parameter_types() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PARAMETER_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_RETURN_TYPE, 4) &&
           VerifyOffset(verifier, VT_PARAMETER_TYPES) &&
           verifier.VerifyVector(parameter_types()) &&
           verifier.EndTable();
  }
};

struct MethodMetaBuilder {
  typedef MethodMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(MethodMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(MethodMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(MethodMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_return_type(int32_t return_type) {
    fbb_.AddElement<int32_t>(MethodMeta::VT_RETURN_TYPE, return_type, 0);
  }
  void add_parameter_types(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types) {
    fbb_.AddOffset(MethodMeta::VT_PARAMETER_TYPES, parameter_types);
  }
  explicit MethodMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t return_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> parameter_types = 0) {
  MethodMetaBuilder builder_(_fbb);
  builder_.add_parameter_types(parameter_types);
  builder_.add_return_type(return_type);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct MethodMeta::Traits {
  using type = MethodMeta;
  static auto constexpr Create = CreateMethodMeta;
};

inline ::flatbuffers::Offset<MethodMeta> CreateMethodMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t return_type = 0,
    const std::vector<int32_t> *parameter_types = nullptr) {
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  auto parameter_types__ = parameter_types ? _fbb.CreateVector<int32_t>(*parameter_types) : 0;
  return schema::CreateMethodMeta(
      _fbb,
      id,
      dex_id,
      annotations__,
      access_flags,
      dex_descriptor__,
      return_type,
      parameter_types__);
}

struct FieldMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_ANNOTATIONS = 8,
    VT_ACCESS_FLAGS = 10,
    VT_DEX_DESCRIPTOR = 12,
    VT_TYPE = 14
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::Vector<int32_t> *annotations() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ANNOTATIONS);
  }
  uint32_t access_flags() const {
    return GetField<uint32_t>(VT_ACCESS_FLAGS, 0);
  }
  const ::flatbuffers::String *dex_descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEX_DESCRIPTOR);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyVector(annotations()) &&
           VerifyField<uint32_t>(verifier, VT_ACCESS_FLAGS, 4) &&
           VerifyOffset(verifier, VT_DEX_DESCRIPTOR) &&
           verifier.VerifyString(dex_descriptor()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct FieldMetaBuilder {
  typedef FieldMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_annotations(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations) {
    fbb_.AddOffset(FieldMeta::VT_ANNOTATIONS, annotations);
  }
  void add_access_flags(uint32_t access_flags) {
    fbb_.AddElement<uint32_t>(FieldMeta::VT_ACCESS_FLAGS, access_flags, 0);
  }
  void add_dex_descriptor(::flatbuffers::Offset<::flatbuffers::String> dex_descriptor) {
    fbb_.AddOffset(FieldMeta::VT_DEX_DESCRIPTOR, dex_descriptor);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(FieldMeta::VT_TYPE, type, 0);
  }
  explicit FieldMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> annotations = 0,
    uint32_t access_flags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dex_descriptor = 0,
    int32_t type = 0) {
  FieldMetaBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_dex_descriptor(dex_descriptor);
  builder_.add_access_flags(access_flags);
  builder_.add_annotations(annotations);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  return builder_.Finish();
}

struct FieldMeta::Traits {
  using type = FieldMeta;
  static auto constexpr Create = CreateFieldMeta;
};

inline ::flatbuffers::Offset<FieldMeta> CreateFieldMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    const std::vector<int32_t> *annotations = nullptr,
    uint32_t access_flags = 0,
    const char *dex_descriptor = nullptr,
    int32_t type = 0) {
  auto annotations__ = annotations ? _fbb.CreateVector<int32_t>(*annotations) : 0;
  auto dex_descriptor__ = dex_descriptor ? _fbb.CreateString(dex_descriptor) : 0;
  return schema::CreateFieldMeta(
      _fbb,
      id,
      dex_id,
      annotations__,
      access_flags,
      dex_descriptor__,
      type);
}

struct AnnotationElementValueArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementValueArrayBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUES_TYPE = 4,
    VT_VALUES = 6
  };
  const ::flatbuffers::Vector<schema::AnnotationElementValue> *values_type() const {
    return GetPointer<const ::flatbuffers::Vector<schema::AnnotationElementValue> *>(VT_VALUES_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUES_TYPE) &&
           verifier.VerifyVector(values_type()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyAnnotationElementValueVector(verifier, values(), values_type()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementValueArrayBuilder {
  typedef AnnotationElementValueArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_values_type(::flatbuffers::Offset<::flatbuffers::Vector<schema::AnnotationElementValue>> values_type) {
    fbb_.AddOffset(AnnotationElementValueArray::VT_VALUES_TYPE, values_type);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> values) {
    fbb_.AddOffset(AnnotationElementValueArray::VT_VALUES, values);
  }
  explicit AnnotationElementValueArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementValueArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementValueArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementValueArray> CreateAnnotationElementValueArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<schema::AnnotationElementValue>> values_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> values = 0) {
  AnnotationElementValueArrayBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_values_type(values_type);
  return builder_.Finish();
}

struct AnnotationElementValueArray::Traits {
  using type = AnnotationElementValueArray;
  static auto constexpr Create = CreateAnnotationElementValueArray;
};

inline ::flatbuffers::Offset<AnnotationElementValueArray> CreateAnnotationElementValueArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<schema::AnnotationElementValue> *values_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *values = nullptr) {
  auto values_type__ = values_type ? _fbb.CreateVector<schema::AnnotationElementValue>(*values_type) : 0;
  auto values__ = values ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*values) : 0;
  return schema::CreateAnnotationElementValueArray(
      _fbb,
      values_type__,
      values__);
}

struct AnnotationMember FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMemberBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE_TYPE = 6,
    VT_VALUE = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  schema::AnnotationElementValue value_type() const {
    return static_cast<schema::AnnotationElementValue>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const schema::EncodeValueBoolean *value_as_EncodeValueBoolean() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueBoolean ? static_cast<const schema::EncodeValueBoolean *>(value()) : nullptr;
  }
  const schema::EncodeValueByte *value_as_EncodeValueByte() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueByte ? static_cast<const schema::EncodeValueByte *>(value()) : nullptr;
  }
  const schema::EncodeValueShort *value_as_EncodeValueShort() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueShort ? static_cast<const schema::EncodeValueShort *>(value()) : nullptr;
  }
  const schema::EncodeValueChar *value_as_EncodeValueChar() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueChar ? static_cast<const schema::EncodeValueChar *>(value()) : nullptr;
  }
  const schema::EncodeValueInt *value_as_EncodeValueInt() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueInt ? static_cast<const schema::EncodeValueInt *>(value()) : nullptr;
  }
  const schema::EncodeValueLong *value_as_EncodeValueLong() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueLong ? static_cast<const schema::EncodeValueLong *>(value()) : nullptr;
  }
  const schema::EncodeValueFloat *value_as_EncodeValueFloat() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueFloat ? static_cast<const schema::EncodeValueFloat *>(value()) : nullptr;
  }
  const schema::EncodeValueDouble *value_as_EncodeValueDouble() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueDouble ? static_cast<const schema::EncodeValueDouble *>(value()) : nullptr;
  }
  const schema::EncodeValueString *value_as_EncodeValueString() const {
    return value_type() == schema::AnnotationElementValue::EncodeValueString ? static_cast<const schema::EncodeValueString *>(value()) : nullptr;
  }
  const schema::ClassMeta *value_as_ClassMeta() const {
    return value_type() == schema::AnnotationElementValue::ClassMeta ? static_cast<const schema::ClassMeta *>(value()) : nullptr;
  }
  const schema::AnnotationElementValueArray *value_as_AnnotationElementValueArray() const {
    return value_type() == schema::AnnotationElementValue::AnnotationElementValueArray ? static_cast<const schema::AnnotationElementValueArray *>(value()) : nullptr;
  }
  const schema::AnnotationMeta *value_as_AnnotationMeta() const {
    return value_type() == schema::AnnotationElementValue::AnnotationMeta ? static_cast<const schema::AnnotationMeta *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnnotationElementValue(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const schema::EncodeValueBoolean *AnnotationMember::value_as<schema::EncodeValueBoolean>() const {
  return value_as_EncodeValueBoolean();
}

template<> inline const schema::EncodeValueByte *AnnotationMember::value_as<schema::EncodeValueByte>() const {
  return value_as_EncodeValueByte();
}

template<> inline const schema::EncodeValueShort *AnnotationMember::value_as<schema::EncodeValueShort>() const {
  return value_as_EncodeValueShort();
}

template<> inline const schema::EncodeValueChar *AnnotationMember::value_as<schema::EncodeValueChar>() const {
  return value_as_EncodeValueChar();
}

template<> inline const schema::EncodeValueInt *AnnotationMember::value_as<schema::EncodeValueInt>() const {
  return value_as_EncodeValueInt();
}

template<> inline const schema::EncodeValueLong *AnnotationMember::value_as<schema::EncodeValueLong>() const {
  return value_as_EncodeValueLong();
}

template<> inline const schema::EncodeValueFloat *AnnotationMember::value_as<schema::EncodeValueFloat>() const {
  return value_as_EncodeValueFloat();
}

template<> inline const schema::EncodeValueDouble *AnnotationMember::value_as<schema::EncodeValueDouble>() const {
  return value_as_EncodeValueDouble();
}

template<> inline const schema::EncodeValueString *AnnotationMember::value_as<schema::EncodeValueString>() const {
  return value_as_EncodeValueString();
}

template<> inline const schema::ClassMeta *AnnotationMember::value_as<schema::ClassMeta>() const {
  return value_as_ClassMeta();
}

template<> inline const schema::AnnotationElementValueArray *AnnotationMember::value_as<schema::AnnotationElementValueArray>() const {
  return value_as_AnnotationElementValueArray();
}

template<> inline const schema::AnnotationMeta *AnnotationMember::value_as<schema::AnnotationMeta>() const {
  return value_as_AnnotationMeta();
}

struct AnnotationMemberBuilder {
  typedef AnnotationMember Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnnotationMember::VT_NAME, name);
  }
  void add_value_type(schema::AnnotationElementValue value_type) {
    fbb_.AddElement<uint8_t>(AnnotationMember::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(AnnotationMember::VT_VALUE, value);
  }
  explicit AnnotationMemberBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMember> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMember>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMember> CreateAnnotationMember(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    schema::AnnotationElementValue value_type = schema::AnnotationElementValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  AnnotationMemberBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct AnnotationMember::Traits {
  using type = AnnotationMember;
  static auto constexpr Create = CreateAnnotationMember;
};

inline ::flatbuffers::Offset<AnnotationMember> CreateAnnotationMemberDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    schema::AnnotationElementValue value_type = schema::AnnotationElementValue::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return schema::CreateAnnotationMember(
      _fbb,
      name__,
      value_type,
      value);
}

struct AnnotationMeta FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMetaBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEX_ID = 6,
    VT_TARGET_ELEMENT_TYPES = 8,
    VT_RETENTION_POLICY = 10,
    VT_MEMBERS = 12
  };
  int32_t id() const {
    return GetField<int32_t>(VT_ID, 0);
  }
  int32_t dex_id() const {
    return GetField<int32_t>(VT_DEX_ID, 0);
  }
  const ::flatbuffers::Vector<schema::TargetElementType> *target_element_types() const {
    return GetPointer<const ::flatbuffers::Vector<schema::TargetElementType> *>(VT_TARGET_ELEMENT_TYPES);
  }
  schema::RetentionPolicyType retention_policy() const {
    return static_cast<schema::RetentionPolicyType>(GetField<int8_t>(VT_RETENTION_POLICY, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMember>> *members() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMember>> *>(VT_MEMBERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ID, 4) &&
           VerifyField<int32_t>(verifier, VT_DEX_ID, 4) &&
           VerifyOffset(verifier, VT_TARGET_ELEMENT_TYPES) &&
           verifier.VerifyVector(target_element_types()) &&
           VerifyField<int8_t>(verifier, VT_RETENTION_POLICY, 1) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
};

struct AnnotationMetaBuilder {
  typedef AnnotationMeta Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(int32_t id) {
    fbb_.AddElement<int32_t>(AnnotationMeta::VT_ID, id, 0);
  }
  void add_dex_id(int32_t dex_id) {
    fbb_.AddElement<int32_t>(AnnotationMeta::VT_DEX_ID, dex_id, 0);
  }
  void add_target_element_types(::flatbuffers::Offset<::flatbuffers::Vector<schema::TargetElementType>> target_element_types) {
    fbb_.AddOffset(AnnotationMeta::VT_TARGET_ELEMENT_TYPES, target_element_types);
  }
  void add_retention_policy(schema::RetentionPolicyType retention_policy) {
    fbb_.AddElement<int8_t>(AnnotationMeta::VT_RETENTION_POLICY, static_cast<int8_t>(retention_policy), 0);
  }
  void add_members(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMember>>> members) {
    fbb_.AddOffset(AnnotationMeta::VT_MEMBERS, members);
  }
  explicit AnnotationMetaBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMeta>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMeta(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<schema::TargetElementType>> target_element_types = 0,
    schema::RetentionPolicyType retention_policy = schema::RetentionPolicyType::Source,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMember>>> members = 0) {
  AnnotationMetaBuilder builder_(_fbb);
  builder_.add_members(members);
  builder_.add_target_element_types(target_element_types);
  builder_.add_dex_id(dex_id);
  builder_.add_id(id);
  builder_.add_retention_policy(retention_policy);
  return builder_.Finish();
}

struct AnnotationMeta::Traits {
  using type = AnnotationMeta;
  static auto constexpr Create = CreateAnnotationMeta;
};

inline ::flatbuffers::Offset<AnnotationMeta> CreateAnnotationMetaDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t id = 0,
    int32_t dex_id = 0,
    const std::vector<schema::TargetElementType> *target_element_types = nullptr,
    schema::RetentionPolicyType retention_policy = schema::RetentionPolicyType::Source,
    const std::vector<::flatbuffers::Offset<schema::AnnotationMember>> *members = nullptr) {
  auto target_element_types__ = target_element_types ? _fbb.CreateVector<schema::TargetElementType>(*target_element_types) : 0;
  auto members__ = members ? _fbb.CreateVector<::flatbuffers::Offset<schema::AnnotationMember>>(*members) : 0;
  return schema::CreateAnnotationMeta(
      _fbb,
      id,
      dex_id,
      target_element_types__,
      retention_policy,
      members__);
}

inline bool VerifyAnnotationElementValue(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValue type) {
  switch (type) {
    case AnnotationElementValue::NONE: {
      return true;
    }
    case AnnotationElementValue::EncodeValueBoolean: {
      auto ptr = reinterpret_cast<const schema::EncodeValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueByte: {
      auto ptr = reinterpret_cast<const schema::EncodeValueByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueShort: {
      auto ptr = reinterpret_cast<const schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueChar: {
      auto ptr = reinterpret_cast<const schema::EncodeValueChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueInt: {
      auto ptr = reinterpret_cast<const schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueLong: {
      auto ptr = reinterpret_cast<const schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::EncodeValueString: {
      auto ptr = reinterpret_cast<const schema::EncodeValueString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::ClassMeta: {
      auto ptr = reinterpret_cast<const schema::ClassMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::AnnotationElementValueArray: {
      auto ptr = reinterpret_cast<const schema::AnnotationElementValueArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValue::AnnotationMeta: {
      auto ptr = reinterpret_cast<const schema::AnnotationMeta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnnotationElementValueVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnnotationElementValue(
        verifier,  values->Get(i), types->GetEnum<AnnotationElementValue>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema

#endif  // FLATBUFFERS_GENERATED_RESULTS_SCHEMA_H_
