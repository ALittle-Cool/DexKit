// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MATCHERS_SCHEMA_H_
#define FLATBUFFERS_GENERATED_MATCHERS_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 5 &&
              FLATBUFFERS_VERSION_REVISION == 26,
             "Non-compatible flatbuffers version included");

#include "encode_value_generated.h"
#include "enums_generated.h"
#include "ranges_generated.h"

namespace schema {

struct StringMatcher;
struct StringMatcherBuilder;

struct AccessFlagsMatcher;
struct AccessFlagsMatcherBuilder;

struct TargetElementTypesMatcher;
struct TargetElementTypesMatcherBuilder;

struct OptionalAnnotationElementValueMatcher;
struct OptionalAnnotationElementValueMatcherBuilder;

struct AnnotationElementMatcher;
struct AnnotationElementMatcherBuilder;

struct OptionalAnnotationElementMatcher;
struct OptionalAnnotationElementMatcherBuilder;

struct AnnotationElementsMatcher;
struct AnnotationElementsMatcherBuilder;

struct AnnotationMatcher;
struct AnnotationMatcherBuilder;

struct AnnotationsMatcher;
struct AnnotationsMatcherBuilder;

struct ParameterMatcher;
struct ParameterMatcherBuilder;

struct OptionalParameterMatcher;
struct OptionalParameterMatcherBuilder;

struct ParametersMatcher;
struct ParametersMatcherBuilder;

struct OpCodesMatcher;
struct OpCodesMatcherBuilder;

struct UsingFieldMatcher;
struct UsingFieldMatcherBuilder;

struct UsingNumberMatcher;
struct UsingNumberMatcherBuilder;

struct MethodMatcher;
struct MethodMatcherBuilder;

struct MethodsMatcher;
struct MethodsMatcherBuilder;

struct InterfacesMatcher;
struct InterfacesMatcherBuilder;

struct FieldMatcher;
struct FieldMatcherBuilder;

struct FieldsMatcher;
struct FieldsMatcherBuilder;

struct ClassMatcher;
struct ClassMatcherBuilder;

struct BatchUsingStringsMatcher;
struct BatchUsingStringsMatcherBuilder;

enum class AnnotationElementValueMatcher : uint8_t {
  NONE = 0,
  EncodeValueBoolean = 1,
  EncodeValueByte = 2,
  EncodeValueShort = 3,
  EncodeValueChar = 4,
  EncodeValueInt = 5,
  EncodeValueLong = 6,
  EncodeValueFloat = 7,
  EncodeValueDouble = 8,
  StringMatcher = 9,
  ClassMatcher = 10,
  AnnotationElementsMatcher = 11,
  AnnotationMatcher = 12,
  MIN = NONE,
  MAX = AnnotationMatcher
};

inline const AnnotationElementValueMatcher (&EnumValuesAnnotationElementValueMatcher())[13] {
  static const AnnotationElementValueMatcher values[] = {
    AnnotationElementValueMatcher::NONE,
    AnnotationElementValueMatcher::EncodeValueBoolean,
    AnnotationElementValueMatcher::EncodeValueByte,
    AnnotationElementValueMatcher::EncodeValueShort,
    AnnotationElementValueMatcher::EncodeValueChar,
    AnnotationElementValueMatcher::EncodeValueInt,
    AnnotationElementValueMatcher::EncodeValueLong,
    AnnotationElementValueMatcher::EncodeValueFloat,
    AnnotationElementValueMatcher::EncodeValueDouble,
    AnnotationElementValueMatcher::StringMatcher,
    AnnotationElementValueMatcher::ClassMatcher,
    AnnotationElementValueMatcher::AnnotationElementsMatcher,
    AnnotationElementValueMatcher::AnnotationMatcher
  };
  return values;
}

inline const char * const *EnumNamesAnnotationElementValueMatcher() {
  static const char * const names[14] = {
    "NONE",
    "EncodeValueBoolean",
    "EncodeValueByte",
    "EncodeValueShort",
    "EncodeValueChar",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    "StringMatcher",
    "ClassMatcher",
    "AnnotationElementsMatcher",
    "AnnotationMatcher",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnnotationElementValueMatcher(AnnotationElementValueMatcher e) {
  if (::flatbuffers::IsOutRange(e, AnnotationElementValueMatcher::NONE, AnnotationElementValueMatcher::AnnotationMatcher)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnnotationElementValueMatcher()[index];
}

template<typename T> struct AnnotationElementValueMatcherTraits {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::NONE;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueBoolean> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueBoolean;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueByte> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueByte;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueShort> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueShort;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueChar> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueChar;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueInt> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueInt;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueLong> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueLong;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueFloat> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueFloat;
};

template<> struct AnnotationElementValueMatcherTraits<schema::EncodeValueDouble> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::EncodeValueDouble;
};

template<> struct AnnotationElementValueMatcherTraits<schema::StringMatcher> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::StringMatcher;
};

template<> struct AnnotationElementValueMatcherTraits<schema::ClassMatcher> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::ClassMatcher;
};

template<> struct AnnotationElementValueMatcherTraits<schema::AnnotationElementsMatcher> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::AnnotationElementsMatcher;
};

template<> struct AnnotationElementValueMatcherTraits<schema::AnnotationMatcher> {
  static const AnnotationElementValueMatcher enum_value = AnnotationElementValueMatcher::AnnotationMatcher;
};

bool VerifyAnnotationElementValueMatcher(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValueMatcher type);
bool VerifyAnnotationElementValueMatcherVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValueMatcher> *types);

enum class Number : uint8_t {
  NONE = 0,
  EncodeValueShort = 1,
  EncodeValueInt = 2,
  EncodeValueLong = 3,
  EncodeValueFloat = 4,
  EncodeValueDouble = 5,
  MIN = NONE,
  MAX = EncodeValueDouble
};

inline const Number (&EnumValuesNumber())[6] {
  static const Number values[] = {
    Number::NONE,
    Number::EncodeValueShort,
    Number::EncodeValueInt,
    Number::EncodeValueLong,
    Number::EncodeValueFloat,
    Number::EncodeValueDouble
  };
  return values;
}

inline const char * const *EnumNamesNumber() {
  static const char * const names[7] = {
    "NONE",
    "EncodeValueShort",
    "EncodeValueInt",
    "EncodeValueLong",
    "EncodeValueFloat",
    "EncodeValueDouble",
    nullptr
  };
  return names;
}

inline const char *EnumNameNumber(Number e) {
  if (::flatbuffers::IsOutRange(e, Number::NONE, Number::EncodeValueDouble)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNumber()[index];
}

template<typename T> struct NumberTraits {
  static const Number enum_value = Number::NONE;
};

template<> struct NumberTraits<schema::EncodeValueShort> {
  static const Number enum_value = Number::EncodeValueShort;
};

template<> struct NumberTraits<schema::EncodeValueInt> {
  static const Number enum_value = Number::EncodeValueInt;
};

template<> struct NumberTraits<schema::EncodeValueLong> {
  static const Number enum_value = Number::EncodeValueLong;
};

template<> struct NumberTraits<schema::EncodeValueFloat> {
  static const Number enum_value = Number::EncodeValueFloat;
};

template<> struct NumberTraits<schema::EncodeValueDouble> {
  static const Number enum_value = Number::EncodeValueDouble;
};

bool VerifyNumber(::flatbuffers::Verifier &verifier, const void *obj, Number type);
bool VerifyNumberVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Number> *types);

struct StringMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_VALUE = 6
  };
  schema::StringMatchType type() const {
    return static_cast<schema::StringMatchType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct StringMatcherBuilder {
  typedef StringMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(schema::StringMatchType type) {
    fbb_.AddElement<int8_t>(StringMatcher::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(StringMatcher::VT_VALUE, value);
  }
  explicit StringMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringMatcher> CreateStringMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::StringMatchType type = schema::StringMatchType::Contains,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  StringMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_type(type);
  return builder_.Finish();
}

struct StringMatcher::Traits {
  using type = StringMatcher;
  static auto constexpr Create = CreateStringMatcher;
};

inline ::flatbuffers::Offset<StringMatcher> CreateStringMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::StringMatchType type = schema::StringMatchType::Contains,
    const char *value = nullptr) {
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return schema::CreateStringMatcher(
      _fbb,
      type,
      value__);
}

struct AccessFlagsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AccessFlagsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATCH_TYPE = 4,
    VT_FLAGS = 6
  };
  schema::MatchType match_type() const {
    return static_cast<schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  uint32_t flags() const {
    return GetField<uint32_t>(VT_FLAGS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           verifier.EndTable();
  }
};

struct AccessFlagsMatcherBuilder {
  typedef AccessFlagsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_match_type(schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(AccessFlagsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_flags(uint32_t flags) {
    fbb_.AddElement<uint32_t>(AccessFlagsMatcher::VT_FLAGS, flags, 0);
  }
  explicit AccessFlagsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AccessFlagsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AccessFlagsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AccessFlagsMatcher> CreateAccessFlagsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::MatchType match_type = schema::MatchType::Equal,
    uint32_t flags = 0) {
  AccessFlagsMatcherBuilder builder_(_fbb);
  builder_.add_flags(flags);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct AccessFlagsMatcher::Traits {
  using type = AccessFlagsMatcher;
  static auto constexpr Create = CreateAccessFlagsMatcher;
};

struct TargetElementTypesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TargetElementTypesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTAIN_TYPES = 4
  };
  const ::flatbuffers::Vector<schema::TargetElementType> *contain_types() const {
    return GetPointer<const ::flatbuffers::Vector<schema::TargetElementType> *>(VT_CONTAIN_TYPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTAIN_TYPES) &&
           verifier.VerifyVector(contain_types()) &&
           verifier.EndTable();
  }
};

struct TargetElementTypesMatcherBuilder {
  typedef TargetElementTypesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_contain_types(::flatbuffers::Offset<::flatbuffers::Vector<schema::TargetElementType>> contain_types) {
    fbb_.AddOffset(TargetElementTypesMatcher::VT_CONTAIN_TYPES, contain_types);
  }
  explicit TargetElementTypesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TargetElementTypesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TargetElementTypesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TargetElementTypesMatcher> CreateTargetElementTypesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<schema::TargetElementType>> contain_types = 0) {
  TargetElementTypesMatcherBuilder builder_(_fbb);
  builder_.add_contain_types(contain_types);
  return builder_.Finish();
}

struct TargetElementTypesMatcher::Traits {
  using type = TargetElementTypesMatcher;
  static auto constexpr Create = CreateTargetElementTypesMatcher;
};

inline ::flatbuffers::Offset<TargetElementTypesMatcher> CreateTargetElementTypesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<schema::TargetElementType> *contain_types = nullptr) {
  auto contain_types__ = contain_types ? _fbb.CreateVector<schema::TargetElementType>(*contain_types) : 0;
  return schema::CreateTargetElementTypesMatcher(
      _fbb,
      contain_types__);
}

struct OptionalAnnotationElementValueMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalAnnotationElementValueMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  schema::AnnotationElementValueMatcher value_type() const {
    return static_cast<schema::AnnotationElementValueMatcher>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const schema::EncodeValueBoolean *value_as_EncodeValueBoolean() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueBoolean ? static_cast<const schema::EncodeValueBoolean *>(value()) : nullptr;
  }
  const schema::EncodeValueByte *value_as_EncodeValueByte() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueByte ? static_cast<const schema::EncodeValueByte *>(value()) : nullptr;
  }
  const schema::EncodeValueShort *value_as_EncodeValueShort() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueShort ? static_cast<const schema::EncodeValueShort *>(value()) : nullptr;
  }
  const schema::EncodeValueChar *value_as_EncodeValueChar() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueChar ? static_cast<const schema::EncodeValueChar *>(value()) : nullptr;
  }
  const schema::EncodeValueInt *value_as_EncodeValueInt() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueInt ? static_cast<const schema::EncodeValueInt *>(value()) : nullptr;
  }
  const schema::EncodeValueLong *value_as_EncodeValueLong() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueLong ? static_cast<const schema::EncodeValueLong *>(value()) : nullptr;
  }
  const schema::EncodeValueFloat *value_as_EncodeValueFloat() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueFloat ? static_cast<const schema::EncodeValueFloat *>(value()) : nullptr;
  }
  const schema::EncodeValueDouble *value_as_EncodeValueDouble() const {
    return value_type() == schema::AnnotationElementValueMatcher::EncodeValueDouble ? static_cast<const schema::EncodeValueDouble *>(value()) : nullptr;
  }
  const schema::StringMatcher *value_as_StringMatcher() const {
    return value_type() == schema::AnnotationElementValueMatcher::StringMatcher ? static_cast<const schema::StringMatcher *>(value()) : nullptr;
  }
  const schema::ClassMatcher *value_as_ClassMatcher() const {
    return value_type() == schema::AnnotationElementValueMatcher::ClassMatcher ? static_cast<const schema::ClassMatcher *>(value()) : nullptr;
  }
  const schema::AnnotationElementsMatcher *value_as_AnnotationElementsMatcher() const {
    return value_type() == schema::AnnotationElementValueMatcher::AnnotationElementsMatcher ? static_cast<const schema::AnnotationElementsMatcher *>(value()) : nullptr;
  }
  const schema::AnnotationMatcher *value_as_AnnotationMatcher() const {
    return value_type() == schema::AnnotationElementValueMatcher::AnnotationMatcher ? static_cast<const schema::AnnotationMatcher *>(value()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyAnnotationElementValueMatcher(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const schema::EncodeValueBoolean *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueBoolean>() const {
  return value_as_EncodeValueBoolean();
}

template<> inline const schema::EncodeValueByte *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueByte>() const {
  return value_as_EncodeValueByte();
}

template<> inline const schema::EncodeValueShort *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueShort>() const {
  return value_as_EncodeValueShort();
}

template<> inline const schema::EncodeValueChar *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueChar>() const {
  return value_as_EncodeValueChar();
}

template<> inline const schema::EncodeValueInt *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueInt>() const {
  return value_as_EncodeValueInt();
}

template<> inline const schema::EncodeValueLong *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueLong>() const {
  return value_as_EncodeValueLong();
}

template<> inline const schema::EncodeValueFloat *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueFloat>() const {
  return value_as_EncodeValueFloat();
}

template<> inline const schema::EncodeValueDouble *OptionalAnnotationElementValueMatcher::value_as<schema::EncodeValueDouble>() const {
  return value_as_EncodeValueDouble();
}

template<> inline const schema::StringMatcher *OptionalAnnotationElementValueMatcher::value_as<schema::StringMatcher>() const {
  return value_as_StringMatcher();
}

template<> inline const schema::ClassMatcher *OptionalAnnotationElementValueMatcher::value_as<schema::ClassMatcher>() const {
  return value_as_ClassMatcher();
}

template<> inline const schema::AnnotationElementsMatcher *OptionalAnnotationElementValueMatcher::value_as<schema::AnnotationElementsMatcher>() const {
  return value_as_AnnotationElementsMatcher();
}

template<> inline const schema::AnnotationMatcher *OptionalAnnotationElementValueMatcher::value_as<schema::AnnotationMatcher>() const {
  return value_as_AnnotationMatcher();
}

struct OptionalAnnotationElementValueMatcherBuilder {
  typedef OptionalAnnotationElementValueMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_type(schema::AnnotationElementValueMatcher value_type) {
    fbb_.AddElement<uint8_t>(OptionalAnnotationElementValueMatcher::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(::flatbuffers::Offset<void> value) {
    fbb_.AddOffset(OptionalAnnotationElementValueMatcher::VT_VALUE, value);
  }
  explicit OptionalAnnotationElementValueMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalAnnotationElementValueMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalAnnotationElementValueMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalAnnotationElementValueMatcher> CreateOptionalAnnotationElementValueMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::AnnotationElementValueMatcher value_type = schema::AnnotationElementValueMatcher::NONE,
    ::flatbuffers::Offset<void> value = 0) {
  OptionalAnnotationElementValueMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct OptionalAnnotationElementValueMatcher::Traits {
  using type = OptionalAnnotationElementValueMatcher;
  static auto constexpr Create = CreateOptionalAnnotationElementValueMatcher;
};

struct AnnotationElementMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VALUE = 6
  };
  const schema::StringMatcher *name() const {
    return GetPointer<const schema::StringMatcher *>(VT_NAME);
  }
  const schema::OptionalAnnotationElementValueMatcher *value() const {
    return GetPointer<const schema::OptionalAnnotationElementValueMatcher *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyTable(name()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementMatcherBuilder {
  typedef AnnotationElementMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<schema::StringMatcher> name) {
    fbb_.AddOffset(AnnotationElementMatcher::VT_NAME, name);
  }
  void add_value(::flatbuffers::Offset<schema::OptionalAnnotationElementValueMatcher> value) {
    fbb_.AddOffset(AnnotationElementMatcher::VT_VALUE, value);
  }
  explicit AnnotationElementMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementMatcher> CreateAnnotationElementMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> name = 0,
    ::flatbuffers::Offset<schema::OptionalAnnotationElementValueMatcher> value = 0) {
  AnnotationElementMatcherBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_name(name);
  return builder_.Finish();
}

struct AnnotationElementMatcher::Traits {
  using type = AnnotationElementMatcher;
  static auto constexpr Create = CreateAnnotationElementMatcher;
};

struct OptionalAnnotationElementMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalAnnotationElementMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT = 4
  };
  const schema::AnnotationElementMatcher *element() const {
    return GetPointer<const schema::AnnotationElementMatcher *>(VT_ELEMENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ELEMENT) &&
           verifier.VerifyTable(element()) &&
           verifier.EndTable();
  }
};

struct OptionalAnnotationElementMatcherBuilder {
  typedef OptionalAnnotationElementMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_element(::flatbuffers::Offset<schema::AnnotationElementMatcher> element) {
    fbb_.AddOffset(OptionalAnnotationElementMatcher::VT_ELEMENT, element);
  }
  explicit OptionalAnnotationElementMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalAnnotationElementMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalAnnotationElementMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalAnnotationElementMatcher> CreateOptionalAnnotationElementMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::AnnotationElementMatcher> element = 0) {
  OptionalAnnotationElementMatcherBuilder builder_(_fbb);
  builder_.add_element(element);
  return builder_.Finish();
}

struct OptionalAnnotationElementMatcher::Traits {
  using type = OptionalAnnotationElementMatcher;
  static auto constexpr Create = CreateOptionalAnnotationElementMatcher;
};

struct AnnotationElementsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationElementsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_COUNT = 4,
    VT_MATCH_TYPE = 6,
    VT_ELEMENTS = 8
  };
  const schema::IntRange *value_count() const {
    return GetPointer<const schema::IntRange *>(VT_VALUE_COUNT);
  }
  schema::MatchType match_type() const {
    return static_cast<schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>> *elements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>> *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VALUE_COUNT) &&
           verifier.VerifyTable(value_count()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
};

struct AnnotationElementsMatcherBuilder {
  typedef AnnotationElementsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_value_count(::flatbuffers::Offset<schema::IntRange> value_count) {
    fbb_.AddOffset(AnnotationElementsMatcher::VT_VALUE_COUNT, value_count);
  }
  void add_match_type(schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(AnnotationElementsMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>>> elements) {
    fbb_.AddOffset(AnnotationElementsMatcher::VT_ELEMENTS, elements);
  }
  explicit AnnotationElementsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationElementsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationElementsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationElementsMatcher> CreateAnnotationElementsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> value_count = 0,
    schema::MatchType match_type = schema::MatchType::Equal,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>>> elements = 0) {
  AnnotationElementsMatcherBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_value_count(value_count);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct AnnotationElementsMatcher::Traits {
  using type = AnnotationElementsMatcher;
  static auto constexpr Create = CreateAnnotationElementsMatcher;
};

inline ::flatbuffers::Offset<AnnotationElementsMatcher> CreateAnnotationElementsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> value_count = 0,
    schema::MatchType match_type = schema::MatchType::Equal,
    const std::vector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>> *elements = nullptr) {
  auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<schema::OptionalAnnotationElementMatcher>>(*elements) : 0;
  return schema::CreateAnnotationElementsMatcher(
      _fbb,
      value_count,
      match_type,
      elements__);
}

struct AnnotationMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE_NAME = 4,
    VT_TARGET_ELEMENT_TYPES = 6,
    VT_POLICY = 8,
    VT_ANNOTATIONS = 10,
    VT_ELEMENTS = 12
  };
  const schema::StringMatcher *type_name() const {
    return GetPointer<const schema::StringMatcher *>(VT_TYPE_NAME);
  }
  const schema::TargetElementTypesMatcher *target_element_types() const {
    return GetPointer<const schema::TargetElementTypesMatcher *>(VT_TARGET_ELEMENT_TYPES);
  }
  schema::RetentionPolicyType policy() const {
    return static_cast<schema::RetentionPolicyType>(GetField<int8_t>(VT_POLICY, 0));
  }
  const schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const schema::AnnotationElementsMatcher *elements() const {
    return GetPointer<const schema::AnnotationElementsMatcher *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyTable(type_name()) &&
           VerifyOffset(verifier, VT_TARGET_ELEMENT_TYPES) &&
           verifier.VerifyTable(target_element_types()) &&
           VerifyField<int8_t>(verifier, VT_POLICY, 1) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_ELEMENTS) &&
           verifier.VerifyTable(elements()) &&
           verifier.EndTable();
  }
};

struct AnnotationMatcherBuilder {
  typedef AnnotationMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type_name(::flatbuffers::Offset<schema::StringMatcher> type_name) {
    fbb_.AddOffset(AnnotationMatcher::VT_TYPE_NAME, type_name);
  }
  void add_target_element_types(::flatbuffers::Offset<schema::TargetElementTypesMatcher> target_element_types) {
    fbb_.AddOffset(AnnotationMatcher::VT_TARGET_ELEMENT_TYPES, target_element_types);
  }
  void add_policy(schema::RetentionPolicyType policy) {
    fbb_.AddElement<int8_t>(AnnotationMatcher::VT_POLICY, static_cast<int8_t>(policy), 0);
  }
  void add_annotations(::flatbuffers::Offset<schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(AnnotationMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_elements(::flatbuffers::Offset<schema::AnnotationElementsMatcher> elements) {
    fbb_.AddOffset(AnnotationMatcher::VT_ELEMENTS, elements);
  }
  explicit AnnotationMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationMatcher> CreateAnnotationMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> type_name = 0,
    ::flatbuffers::Offset<schema::TargetElementTypesMatcher> target_element_types = 0,
    schema::RetentionPolicyType policy = schema::RetentionPolicyType::Source,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::AnnotationElementsMatcher> elements = 0) {
  AnnotationMatcherBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_annotations(annotations);
  builder_.add_target_element_types(target_element_types);
  builder_.add_type_name(type_name);
  builder_.add_policy(policy);
  return builder_.Finish();
}

struct AnnotationMatcher::Traits {
  using type = AnnotationMatcher;
  static auto constexpr Create = CreateAnnotationMatcher;
};

struct AnnotationsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnnotationsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANNOTAION_COUNT = 4,
    VT_CONTAIN_ANNOTATIONS = 6
  };
  const schema::IntRange *annotaion_count() const {
    return GetPointer<const schema::IntRange *>(VT_ANNOTAION_COUNT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMatcher>> *contain_annotations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMatcher>> *>(VT_CONTAIN_ANNOTATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ANNOTAION_COUNT) &&
           verifier.VerifyTable(annotaion_count()) &&
           VerifyOffset(verifier, VT_CONTAIN_ANNOTATIONS) &&
           verifier.VerifyVector(contain_annotations()) &&
           verifier.VerifyVectorOfTables(contain_annotations()) &&
           verifier.EndTable();
  }
};

struct AnnotationsMatcherBuilder {
  typedef AnnotationsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_annotaion_count(::flatbuffers::Offset<schema::IntRange> annotaion_count) {
    fbb_.AddOffset(AnnotationsMatcher::VT_ANNOTAION_COUNT, annotaion_count);
  }
  void add_contain_annotations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMatcher>>> contain_annotations) {
    fbb_.AddOffset(AnnotationsMatcher::VT_CONTAIN_ANNOTATIONS, contain_annotations);
  }
  explicit AnnotationsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnnotationsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnnotationsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnnotationsMatcher> CreateAnnotationsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> annotaion_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::AnnotationMatcher>>> contain_annotations = 0) {
  AnnotationsMatcherBuilder builder_(_fbb);
  builder_.add_contain_annotations(contain_annotations);
  builder_.add_annotaion_count(annotaion_count);
  return builder_.Finish();
}

struct AnnotationsMatcher::Traits {
  using type = AnnotationsMatcher;
  static auto constexpr Create = CreateAnnotationsMatcher;
};

inline ::flatbuffers::Offset<AnnotationsMatcher> CreateAnnotationsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> annotaion_count = 0,
    const std::vector<::flatbuffers::Offset<schema::AnnotationMatcher>> *contain_annotations = nullptr) {
  auto contain_annotations__ = contain_annotations ? _fbb.CreateVector<::flatbuffers::Offset<schema::AnnotationMatcher>>(*contain_annotations) : 0;
  return schema::CreateAnnotationsMatcher(
      _fbb,
      annotaion_count,
      contain_annotations__);
}

struct ParameterMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParameterMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PRAMETER_TYPE = 4,
    VT_ANNOTATIONS = 6
  };
  const schema::ClassMatcher *prameter_type() const {
    return GetPointer<const schema::ClassMatcher *>(VT_PRAMETER_TYPE);
  }
  const schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRAMETER_TYPE) &&
           verifier.VerifyTable(prameter_type()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           verifier.EndTable();
  }
};

struct ParameterMatcherBuilder {
  typedef ParameterMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_prameter_type(::flatbuffers::Offset<schema::ClassMatcher> prameter_type) {
    fbb_.AddOffset(ParameterMatcher::VT_PRAMETER_TYPE, prameter_type);
  }
  void add_annotations(::flatbuffers::Offset<schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(ParameterMatcher::VT_ANNOTATIONS, annotations);
  }
  explicit ParameterMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParameterMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParameterMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParameterMatcher> CreateParameterMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::ClassMatcher> prameter_type = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0) {
  ParameterMatcherBuilder builder_(_fbb);
  builder_.add_annotations(annotations);
  builder_.add_prameter_type(prameter_type);
  return builder_.Finish();
}

struct ParameterMatcher::Traits {
  using type = ParameterMatcher;
  static auto constexpr Create = CreateParameterMatcher;
};

struct OptionalParameterMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OptionalParameterMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER = 4
  };
  const schema::ParameterMatcher *parameter() const {
    return GetPointer<const schema::ParameterMatcher *>(VT_PARAMETER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           verifier.VerifyTable(parameter()) &&
           verifier.EndTable();
  }
};

struct OptionalParameterMatcherBuilder {
  typedef OptionalParameterMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parameter(::flatbuffers::Offset<schema::ParameterMatcher> parameter) {
    fbb_.AddOffset(OptionalParameterMatcher::VT_PARAMETER, parameter);
  }
  explicit OptionalParameterMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OptionalParameterMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OptionalParameterMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OptionalParameterMatcher> CreateOptionalParameterMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::ParameterMatcher> parameter = 0) {
  OptionalParameterMatcherBuilder builder_(_fbb);
  builder_.add_parameter(parameter);
  return builder_.Finish();
}

struct OptionalParameterMatcher::Traits {
  using type = OptionalParameterMatcher;
  static auto constexpr Create = CreateOptionalParameterMatcher;
};

struct ParametersMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ParametersMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARAMETER_COUNT = 4,
    VT_MATCH_TYPE = 6,
    VT_PARAMETERS = 8
  };
  const schema::IntRange *parameter_count() const {
    return GetPointer<const schema::IntRange *>(VT_PARAMETER_COUNT);
  }
  schema::MatchType match_type() const {
    return static_cast<schema::MatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalParameterMatcher>> *parameters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalParameterMatcher>> *>(VT_PARAMETERS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARAMETER_COUNT) &&
           verifier.VerifyTable(parameter_count()) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyVector(parameters()) &&
           verifier.VerifyVectorOfTables(parameters()) &&
           verifier.EndTable();
  }
};

struct ParametersMatcherBuilder {
  typedef ParametersMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_parameter_count(::flatbuffers::Offset<schema::IntRange> parameter_count) {
    fbb_.AddOffset(ParametersMatcher::VT_PARAMETER_COUNT, parameter_count);
  }
  void add_match_type(schema::MatchType match_type) {
    fbb_.AddElement<int8_t>(ParametersMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_parameters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalParameterMatcher>>> parameters) {
    fbb_.AddOffset(ParametersMatcher::VT_PARAMETERS, parameters);
  }
  explicit ParametersMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ParametersMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ParametersMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ParametersMatcher> CreateParametersMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> parameter_count = 0,
    schema::MatchType match_type = schema::MatchType::Equal,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::OptionalParameterMatcher>>> parameters = 0) {
  ParametersMatcherBuilder builder_(_fbb);
  builder_.add_parameters(parameters);
  builder_.add_parameter_count(parameter_count);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct ParametersMatcher::Traits {
  using type = ParametersMatcher;
  static auto constexpr Create = CreateParametersMatcher;
};

inline ::flatbuffers::Offset<ParametersMatcher> CreateParametersMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> parameter_count = 0,
    schema::MatchType match_type = schema::MatchType::Equal,
    const std::vector<::flatbuffers::Offset<schema::OptionalParameterMatcher>> *parameters = nullptr) {
  auto parameters__ = parameters ? _fbb.CreateVector<::flatbuffers::Offset<schema::OptionalParameterMatcher>>(*parameters) : 0;
  return schema::CreateParametersMatcher(
      _fbb,
      parameter_count,
      match_type,
      parameters__);
}

struct OpCodesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OpCodesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATCH_TYPE = 4,
    VT_OP_CODES = 6
  };
  schema::OpCodeMatchType match_type() const {
    return static_cast<schema::OpCodeMatchType>(GetField<int8_t>(VT_MATCH_TYPE, 0));
  }
  const ::flatbuffers::Vector<int16_t> *op_codes() const {
    return GetPointer<const ::flatbuffers::Vector<int16_t> *>(VT_OP_CODES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MATCH_TYPE, 1) &&
           VerifyOffset(verifier, VT_OP_CODES) &&
           verifier.VerifyVector(op_codes()) &&
           verifier.EndTable();
  }
};

struct OpCodesMatcherBuilder {
  typedef OpCodesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_match_type(schema::OpCodeMatchType match_type) {
    fbb_.AddElement<int8_t>(OpCodesMatcher::VT_MATCH_TYPE, static_cast<int8_t>(match_type), 0);
  }
  void add_op_codes(::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> op_codes) {
    fbb_.AddOffset(OpCodesMatcher::VT_OP_CODES, op_codes);
  }
  explicit OpCodesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OpCodesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OpCodesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OpCodesMatcher> CreateOpCodesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::OpCodeMatchType match_type = schema::OpCodeMatchType::Contains,
    ::flatbuffers::Offset<::flatbuffers::Vector<int16_t>> op_codes = 0) {
  OpCodesMatcherBuilder builder_(_fbb);
  builder_.add_op_codes(op_codes);
  builder_.add_match_type(match_type);
  return builder_.Finish();
}

struct OpCodesMatcher::Traits {
  using type = OpCodesMatcher;
  static auto constexpr Create = CreateOpCodesMatcher;
};

inline ::flatbuffers::Offset<OpCodesMatcher> CreateOpCodesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::OpCodeMatchType match_type = schema::OpCodeMatchType::Contains,
    const std::vector<int16_t> *op_codes = nullptr) {
  auto op_codes__ = op_codes ? _fbb.CreateVector<int16_t>(*op_codes) : 0;
  return schema::CreateOpCodesMatcher(
      _fbb,
      match_type,
      op_codes__);
}

struct UsingFieldMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingFieldMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USING_TYPE = 4,
    VT_FIELD = 6
  };
  schema::UsingType using_type() const {
    return static_cast<schema::UsingType>(GetField<int8_t>(VT_USING_TYPE, 0));
  }
  const schema::FieldMatcher *field() const {
    return GetPointer<const schema::FieldMatcher *>(VT_FIELD);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_USING_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIELD) &&
           verifier.VerifyTable(field()) &&
           verifier.EndTable();
  }
};

struct UsingFieldMatcherBuilder {
  typedef UsingFieldMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_using_type(schema::UsingType using_type) {
    fbb_.AddElement<int8_t>(UsingFieldMatcher::VT_USING_TYPE, static_cast<int8_t>(using_type), 0);
  }
  void add_field(::flatbuffers::Offset<schema::FieldMatcher> field) {
    fbb_.AddOffset(UsingFieldMatcher::VT_FIELD, field);
  }
  explicit UsingFieldMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingFieldMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingFieldMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingFieldMatcher> CreateUsingFieldMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::UsingType using_type = schema::UsingType::Any,
    ::flatbuffers::Offset<schema::FieldMatcher> field = 0) {
  UsingFieldMatcherBuilder builder_(_fbb);
  builder_.add_field(field);
  builder_.add_using_type(using_type);
  return builder_.Finish();
}

struct UsingFieldMatcher::Traits {
  using type = UsingFieldMatcher;
  static auto constexpr Create = CreateUsingFieldMatcher;
};

struct UsingNumberMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UsingNumberMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USING_TYPE = 4,
    VT_NUMBER_TYPE = 6,
    VT_NUMBER = 8
  };
  schema::UsingType using_type() const {
    return static_cast<schema::UsingType>(GetField<int8_t>(VT_USING_TYPE, 0));
  }
  schema::Number number_type() const {
    return static_cast<schema::Number>(GetField<uint8_t>(VT_NUMBER_TYPE, 0));
  }
  const void *number() const {
    return GetPointer<const void *>(VT_NUMBER);
  }
  template<typename T> const T *number_as() const;
  const schema::EncodeValueShort *number_as_EncodeValueShort() const {
    return number_type() == schema::Number::EncodeValueShort ? static_cast<const schema::EncodeValueShort *>(number()) : nullptr;
  }
  const schema::EncodeValueInt *number_as_EncodeValueInt() const {
    return number_type() == schema::Number::EncodeValueInt ? static_cast<const schema::EncodeValueInt *>(number()) : nullptr;
  }
  const schema::EncodeValueLong *number_as_EncodeValueLong() const {
    return number_type() == schema::Number::EncodeValueLong ? static_cast<const schema::EncodeValueLong *>(number()) : nullptr;
  }
  const schema::EncodeValueFloat *number_as_EncodeValueFloat() const {
    return number_type() == schema::Number::EncodeValueFloat ? static_cast<const schema::EncodeValueFloat *>(number()) : nullptr;
  }
  const schema::EncodeValueDouble *number_as_EncodeValueDouble() const {
    return number_type() == schema::Number::EncodeValueDouble ? static_cast<const schema::EncodeValueDouble *>(number()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_USING_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_NUMBER_TYPE, 1) &&
           VerifyOffset(verifier, VT_NUMBER) &&
           VerifyNumber(verifier, number(), number_type()) &&
           verifier.EndTable();
  }
};

template<> inline const schema::EncodeValueShort *UsingNumberMatcher::number_as<schema::EncodeValueShort>() const {
  return number_as_EncodeValueShort();
}

template<> inline const schema::EncodeValueInt *UsingNumberMatcher::number_as<schema::EncodeValueInt>() const {
  return number_as_EncodeValueInt();
}

template<> inline const schema::EncodeValueLong *UsingNumberMatcher::number_as<schema::EncodeValueLong>() const {
  return number_as_EncodeValueLong();
}

template<> inline const schema::EncodeValueFloat *UsingNumberMatcher::number_as<schema::EncodeValueFloat>() const {
  return number_as_EncodeValueFloat();
}

template<> inline const schema::EncodeValueDouble *UsingNumberMatcher::number_as<schema::EncodeValueDouble>() const {
  return number_as_EncodeValueDouble();
}

struct UsingNumberMatcherBuilder {
  typedef UsingNumberMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_using_type(schema::UsingType using_type) {
    fbb_.AddElement<int8_t>(UsingNumberMatcher::VT_USING_TYPE, static_cast<int8_t>(using_type), 0);
  }
  void add_number_type(schema::Number number_type) {
    fbb_.AddElement<uint8_t>(UsingNumberMatcher::VT_NUMBER_TYPE, static_cast<uint8_t>(number_type), 0);
  }
  void add_number(::flatbuffers::Offset<void> number) {
    fbb_.AddOffset(UsingNumberMatcher::VT_NUMBER, number);
  }
  explicit UsingNumberMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UsingNumberMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UsingNumberMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UsingNumberMatcher> CreateUsingNumberMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    schema::UsingType using_type = schema::UsingType::Any,
    schema::Number number_type = schema::Number::NONE,
    ::flatbuffers::Offset<void> number = 0) {
  UsingNumberMatcherBuilder builder_(_fbb);
  builder_.add_number(number);
  builder_.add_number_type(number_type);
  builder_.add_using_type(using_type);
  return builder_.Finish();
}

struct UsingNumberMatcher::Traits {
  using type = UsingNumberMatcher;
  static auto constexpr Create = CreateUsingNumberMatcher;
};

struct MethodMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_NAME = 4,
    VT_ACCESS_FLAGS = 6,
    VT_DECLARING_CLASS = 8,
    VT_RETURN_TYPE = 10,
    VT_PARAMETERS = 12,
    VT_ANNOTATIONS = 14,
    VT_OP_CODES = 16,
    VT_USING_STRINGS = 18,
    VT_USING_FIELS = 20,
    VT_USING_NUMBERS = 22,
    VT_INVOKE_METHODS = 24,
    VT_CALL_METHODS = 26
  };
  const schema::StringMatcher *method_name() const {
    return GetPointer<const schema::StringMatcher *>(VT_METHOD_NAME);
  }
  const schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const schema::ClassMatcher *declaring_class() const {
    return GetPointer<const schema::ClassMatcher *>(VT_DECLARING_CLASS);
  }
  const schema::ClassMatcher *return_type() const {
    return GetPointer<const schema::ClassMatcher *>(VT_RETURN_TYPE);
  }
  const schema::ParametersMatcher *parameters() const {
    return GetPointer<const schema::ParametersMatcher *>(VT_PARAMETERS);
  }
  const schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const schema::OpCodesMatcher *op_codes() const {
    return GetPointer<const schema::OpCodesMatcher *>(VT_OP_CODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingFieldMatcher>> *using_fiels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingFieldMatcher>> *>(VT_USING_FIELS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingNumberMatcher>> *using_numbers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingNumberMatcher>> *>(VT_USING_NUMBERS);
  }
  const schema::MethodsMatcher *invoke_methods() const {
    return GetPointer<const schema::MethodsMatcher *>(VT_INVOKE_METHODS);
  }
  const schema::MethodsMatcher *call_methods() const {
    return GetPointer<const schema::MethodsMatcher *>(VT_CALL_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD_NAME) &&
           verifier.VerifyTable(method_name()) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyOffset(verifier, VT_RETURN_TYPE) &&
           verifier.VerifyTable(return_type()) &&
           VerifyOffset(verifier, VT_PARAMETERS) &&
           verifier.VerifyTable(parameters()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_OP_CODES) &&
           verifier.VerifyTable(op_codes()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           VerifyOffset(verifier, VT_USING_FIELS) &&
           verifier.VerifyVector(using_fiels()) &&
           verifier.VerifyVectorOfTables(using_fiels()) &&
           VerifyOffset(verifier, VT_USING_NUMBERS) &&
           verifier.VerifyVector(using_numbers()) &&
           verifier.VerifyVectorOfTables(using_numbers()) &&
           VerifyOffset(verifier, VT_INVOKE_METHODS) &&
           verifier.VerifyTable(invoke_methods()) &&
           VerifyOffset(verifier, VT_CALL_METHODS) &&
           verifier.VerifyTable(call_methods()) &&
           verifier.EndTable();
  }
};

struct MethodMatcherBuilder {
  typedef MethodMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method_name(::flatbuffers::Offset<schema::StringMatcher> method_name) {
    fbb_.AddOffset(MethodMatcher::VT_METHOD_NAME, method_name);
  }
  void add_access_flags(::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(MethodMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_declaring_class(::flatbuffers::Offset<schema::ClassMatcher> declaring_class) {
    fbb_.AddOffset(MethodMatcher::VT_DECLARING_CLASS, declaring_class);
  }
  void add_return_type(::flatbuffers::Offset<schema::ClassMatcher> return_type) {
    fbb_.AddOffset(MethodMatcher::VT_RETURN_TYPE, return_type);
  }
  void add_parameters(::flatbuffers::Offset<schema::ParametersMatcher> parameters) {
    fbb_.AddOffset(MethodMatcher::VT_PARAMETERS, parameters);
  }
  void add_annotations(::flatbuffers::Offset<schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(MethodMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_op_codes(::flatbuffers::Offset<schema::OpCodesMatcher> op_codes) {
    fbb_.AddOffset(MethodMatcher::VT_OP_CODES, op_codes);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(MethodMatcher::VT_USING_STRINGS, using_strings);
  }
  void add_using_fiels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingFieldMatcher>>> using_fiels) {
    fbb_.AddOffset(MethodMatcher::VT_USING_FIELS, using_fiels);
  }
  void add_using_numbers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingNumberMatcher>>> using_numbers) {
    fbb_.AddOffset(MethodMatcher::VT_USING_NUMBERS, using_numbers);
  }
  void add_invoke_methods(::flatbuffers::Offset<schema::MethodsMatcher> invoke_methods) {
    fbb_.AddOffset(MethodMatcher::VT_INVOKE_METHODS, invoke_methods);
  }
  void add_call_methods(::flatbuffers::Offset<schema::MethodsMatcher> call_methods) {
    fbb_.AddOffset(MethodMatcher::VT_CALL_METHODS, call_methods);
  }
  explicit MethodMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodMatcher> CreateMethodMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> method_name = 0,
    ::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> return_type = 0,
    ::flatbuffers::Offset<schema::ParametersMatcher> parameters = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::OpCodesMatcher> op_codes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingFieldMatcher>>> using_fiels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::UsingNumberMatcher>>> using_numbers = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> invoke_methods = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> call_methods = 0) {
  MethodMatcherBuilder builder_(_fbb);
  builder_.add_call_methods(call_methods);
  builder_.add_invoke_methods(invoke_methods);
  builder_.add_using_numbers(using_numbers);
  builder_.add_using_fiels(using_fiels);
  builder_.add_using_strings(using_strings);
  builder_.add_op_codes(op_codes);
  builder_.add_annotations(annotations);
  builder_.add_parameters(parameters);
  builder_.add_return_type(return_type);
  builder_.add_declaring_class(declaring_class);
  builder_.add_access_flags(access_flags);
  builder_.add_method_name(method_name);
  return builder_.Finish();
}

struct MethodMatcher::Traits {
  using type = MethodMatcher;
  static auto constexpr Create = CreateMethodMatcher;
};

inline ::flatbuffers::Offset<MethodMatcher> CreateMethodMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> method_name = 0,
    ::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> return_type = 0,
    ::flatbuffers::Offset<schema::ParametersMatcher> parameters = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::OpCodesMatcher> op_codes = 0,
    const std::vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings = nullptr,
    const std::vector<::flatbuffers::Offset<schema::UsingFieldMatcher>> *using_fiels = nullptr,
    const std::vector<::flatbuffers::Offset<schema::UsingNumberMatcher>> *using_numbers = nullptr,
    ::flatbuffers::Offset<schema::MethodsMatcher> invoke_methods = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> call_methods = 0) {
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<schema::StringMatcher>>(*using_strings) : 0;
  auto using_fiels__ = using_fiels ? _fbb.CreateVector<::flatbuffers::Offset<schema::UsingFieldMatcher>>(*using_fiels) : 0;
  auto using_numbers__ = using_numbers ? _fbb.CreateVector<::flatbuffers::Offset<schema::UsingNumberMatcher>>(*using_numbers) : 0;
  return schema::CreateMethodMatcher(
      _fbb,
      method_name,
      access_flags,
      declaring_class,
      return_type,
      parameters,
      annotations,
      op_codes,
      using_strings__,
      using_fiels__,
      using_numbers__,
      invoke_methods,
      call_methods);
}

struct MethodsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MethodsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD_COUNT = 4,
    VT_CONTAIN_METHODS = 6
  };
  const schema::IntRange *method_count() const {
    return GetPointer<const schema::IntRange *>(VT_METHOD_COUNT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::MethodMatcher>> *contain_methods() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::MethodMatcher>> *>(VT_CONTAIN_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_METHOD_COUNT) &&
           verifier.VerifyTable(method_count()) &&
           VerifyOffset(verifier, VT_CONTAIN_METHODS) &&
           verifier.VerifyVector(contain_methods()) &&
           verifier.VerifyVectorOfTables(contain_methods()) &&
           verifier.EndTable();
  }
};

struct MethodsMatcherBuilder {
  typedef MethodsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method_count(::flatbuffers::Offset<schema::IntRange> method_count) {
    fbb_.AddOffset(MethodsMatcher::VT_METHOD_COUNT, method_count);
  }
  void add_contain_methods(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::MethodMatcher>>> contain_methods) {
    fbb_.AddOffset(MethodsMatcher::VT_CONTAIN_METHODS, contain_methods);
  }
  explicit MethodsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MethodsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MethodsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MethodsMatcher> CreateMethodsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> method_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::MethodMatcher>>> contain_methods = 0) {
  MethodsMatcherBuilder builder_(_fbb);
  builder_.add_contain_methods(contain_methods);
  builder_.add_method_count(method_count);
  return builder_.Finish();
}

struct MethodsMatcher::Traits {
  using type = MethodsMatcher;
  static auto constexpr Create = CreateMethodsMatcher;
};

inline ::flatbuffers::Offset<MethodsMatcher> CreateMethodsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> method_count = 0,
    const std::vector<::flatbuffers::Offset<schema::MethodMatcher>> *contain_methods = nullptr) {
  auto contain_methods__ = contain_methods ? _fbb.CreateVector<::flatbuffers::Offset<schema::MethodMatcher>>(*contain_methods) : 0;
  return schema::CreateMethodsMatcher(
      _fbb,
      method_count,
      contain_methods__);
}

struct InterfacesMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InterfacesMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INTERFACE_COUNT = 4,
    VT_CONTAIN_INTERFACES = 6
  };
  const schema::IntRange *interface_count() const {
    return GetPointer<const schema::IntRange *>(VT_INTERFACE_COUNT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::ClassMatcher>> *contain_interfaces() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::ClassMatcher>> *>(VT_CONTAIN_INTERFACES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INTERFACE_COUNT) &&
           verifier.VerifyTable(interface_count()) &&
           VerifyOffset(verifier, VT_CONTAIN_INTERFACES) &&
           verifier.VerifyVector(contain_interfaces()) &&
           verifier.VerifyVectorOfTables(contain_interfaces()) &&
           verifier.EndTable();
  }
};

struct InterfacesMatcherBuilder {
  typedef InterfacesMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_interface_count(::flatbuffers::Offset<schema::IntRange> interface_count) {
    fbb_.AddOffset(InterfacesMatcher::VT_INTERFACE_COUNT, interface_count);
  }
  void add_contain_interfaces(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::ClassMatcher>>> contain_interfaces) {
    fbb_.AddOffset(InterfacesMatcher::VT_CONTAIN_INTERFACES, contain_interfaces);
  }
  explicit InterfacesMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InterfacesMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InterfacesMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InterfacesMatcher> CreateInterfacesMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> interface_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::ClassMatcher>>> contain_interfaces = 0) {
  InterfacesMatcherBuilder builder_(_fbb);
  builder_.add_contain_interfaces(contain_interfaces);
  builder_.add_interface_count(interface_count);
  return builder_.Finish();
}

struct InterfacesMatcher::Traits {
  using type = InterfacesMatcher;
  static auto constexpr Create = CreateInterfacesMatcher;
};

inline ::flatbuffers::Offset<InterfacesMatcher> CreateInterfacesMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> interface_count = 0,
    const std::vector<::flatbuffers::Offset<schema::ClassMatcher>> *contain_interfaces = nullptr) {
  auto contain_interfaces__ = contain_interfaces ? _fbb.CreateVector<::flatbuffers::Offset<schema::ClassMatcher>>(*contain_interfaces) : 0;
  return schema::CreateInterfacesMatcher(
      _fbb,
      interface_count,
      contain_interfaces__);
}

struct FieldMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACCESS_FLAGS = 4,
    VT_DECLARING_CLASS = 6,
    VT_TYPE_CLASS = 8,
    VT_ANNOTATIONS = 10,
    VT_GET_METHODS = 12,
    VT_PUT_METHODS = 14
  };
  const schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const schema::ClassMatcher *declaring_class() const {
    return GetPointer<const schema::ClassMatcher *>(VT_DECLARING_CLASS);
  }
  const schema::ClassMatcher *type_class() const {
    return GetPointer<const schema::ClassMatcher *>(VT_TYPE_CLASS);
  }
  const schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const schema::MethodsMatcher *get_methods() const {
    return GetPointer<const schema::MethodsMatcher *>(VT_GET_METHODS);
  }
  const schema::MethodsMatcher *put_methods() const {
    return GetPointer<const schema::MethodsMatcher *>(VT_PUT_METHODS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_DECLARING_CLASS) &&
           verifier.VerifyTable(declaring_class()) &&
           VerifyOffset(verifier, VT_TYPE_CLASS) &&
           verifier.VerifyTable(type_class()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_GET_METHODS) &&
           verifier.VerifyTable(get_methods()) &&
           VerifyOffset(verifier, VT_PUT_METHODS) &&
           verifier.VerifyTable(put_methods()) &&
           verifier.EndTable();
  }
};

struct FieldMatcherBuilder {
  typedef FieldMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_access_flags(::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(FieldMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_declaring_class(::flatbuffers::Offset<schema::ClassMatcher> declaring_class) {
    fbb_.AddOffset(FieldMatcher::VT_DECLARING_CLASS, declaring_class);
  }
  void add_type_class(::flatbuffers::Offset<schema::ClassMatcher> type_class) {
    fbb_.AddOffset(FieldMatcher::VT_TYPE_CLASS, type_class);
  }
  void add_annotations(::flatbuffers::Offset<schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(FieldMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_get_methods(::flatbuffers::Offset<schema::MethodsMatcher> get_methods) {
    fbb_.AddOffset(FieldMatcher::VT_GET_METHODS, get_methods);
  }
  void add_put_methods(::flatbuffers::Offset<schema::MethodsMatcher> put_methods) {
    fbb_.AddOffset(FieldMatcher::VT_PUT_METHODS, put_methods);
  }
  explicit FieldMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldMatcher> CreateFieldMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> declaring_class = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> type_class = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> get_methods = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> put_methods = 0) {
  FieldMatcherBuilder builder_(_fbb);
  builder_.add_put_methods(put_methods);
  builder_.add_get_methods(get_methods);
  builder_.add_annotations(annotations);
  builder_.add_type_class(type_class);
  builder_.add_declaring_class(declaring_class);
  builder_.add_access_flags(access_flags);
  return builder_.Finish();
}

struct FieldMatcher::Traits {
  using type = FieldMatcher;
  static auto constexpr Create = CreateFieldMatcher;
};

struct FieldsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FieldsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FIELD_COUNT = 4,
    VT_CONTAIN_FIELDS = 6
  };
  const schema::IntRange *field_count() const {
    return GetPointer<const schema::IntRange *>(VT_FIELD_COUNT);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::FieldMatcher>> *contain_fields() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::FieldMatcher>> *>(VT_CONTAIN_FIELDS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIELD_COUNT) &&
           verifier.VerifyTable(field_count()) &&
           VerifyOffset(verifier, VT_CONTAIN_FIELDS) &&
           verifier.VerifyVector(contain_fields()) &&
           verifier.VerifyVectorOfTables(contain_fields()) &&
           verifier.EndTable();
  }
};

struct FieldsMatcherBuilder {
  typedef FieldsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_field_count(::flatbuffers::Offset<schema::IntRange> field_count) {
    fbb_.AddOffset(FieldsMatcher::VT_FIELD_COUNT, field_count);
  }
  void add_contain_fields(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::FieldMatcher>>> contain_fields) {
    fbb_.AddOffset(FieldsMatcher::VT_CONTAIN_FIELDS, contain_fields);
  }
  explicit FieldsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FieldsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FieldsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FieldsMatcher> CreateFieldsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> field_count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::FieldMatcher>>> contain_fields = 0) {
  FieldsMatcherBuilder builder_(_fbb);
  builder_.add_contain_fields(contain_fields);
  builder_.add_field_count(field_count);
  return builder_.Finish();
}

struct FieldsMatcher::Traits {
  using type = FieldsMatcher;
  static auto constexpr Create = CreateFieldsMatcher;
};

inline ::flatbuffers::Offset<FieldsMatcher> CreateFieldsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::IntRange> field_count = 0,
    const std::vector<::flatbuffers::Offset<schema::FieldMatcher>> *contain_fields = nullptr) {
  auto contain_fields__ = contain_fields ? _fbb.CreateVector<::flatbuffers::Offset<schema::FieldMatcher>>(*contain_fields) : 0;
  return schema::CreateFieldsMatcher(
      _fbb,
      field_count,
      contain_fields__);
}

struct ClassMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClassMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKAGE_NAME = 4,
    VT_SMALI_SOURCE = 6,
    VT_SIMPLE_NAME = 8,
    VT_ACCESS_FLAGS = 10,
    VT_SUPER_CLASS = 12,
    VT_INTERFACES = 14,
    VT_ANNOTATIONS = 16,
    VT_FIELDS = 18,
    VT_METHODS = 20,
    VT_USING_STRINGS = 22
  };
  const schema::StringMatcher *package_name() const {
    return GetPointer<const schema::StringMatcher *>(VT_PACKAGE_NAME);
  }
  const schema::StringMatcher *smali_source() const {
    return GetPointer<const schema::StringMatcher *>(VT_SMALI_SOURCE);
  }
  const schema::StringMatcher *simple_name() const {
    return GetPointer<const schema::StringMatcher *>(VT_SIMPLE_NAME);
  }
  const schema::AccessFlagsMatcher *access_flags() const {
    return GetPointer<const schema::AccessFlagsMatcher *>(VT_ACCESS_FLAGS);
  }
  const schema::ClassMatcher *super_class() const {
    return GetPointer<const schema::ClassMatcher *>(VT_SUPER_CLASS);
  }
  const schema::InterfacesMatcher *interfaces() const {
    return GetPointer<const schema::InterfacesMatcher *>(VT_INTERFACES);
  }
  const schema::AnnotationsMatcher *annotations() const {
    return GetPointer<const schema::AnnotationsMatcher *>(VT_ANNOTATIONS);
  }
  const schema::FieldsMatcher *fields() const {
    return GetPointer<const schema::FieldsMatcher *>(VT_FIELDS);
  }
  const schema::MethodsMatcher *methods() const {
    return GetPointer<const schema::MethodsMatcher *>(VT_METHODS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PACKAGE_NAME) &&
           verifier.VerifyTable(package_name()) &&
           VerifyOffset(verifier, VT_SMALI_SOURCE) &&
           verifier.VerifyTable(smali_source()) &&
           VerifyOffset(verifier, VT_SIMPLE_NAME) &&
           verifier.VerifyTable(simple_name()) &&
           VerifyOffset(verifier, VT_ACCESS_FLAGS) &&
           verifier.VerifyTable(access_flags()) &&
           VerifyOffset(verifier, VT_SUPER_CLASS) &&
           verifier.VerifyTable(super_class()) &&
           VerifyOffset(verifier, VT_INTERFACES) &&
           verifier.VerifyTable(interfaces()) &&
           VerifyOffset(verifier, VT_ANNOTATIONS) &&
           verifier.VerifyTable(annotations()) &&
           VerifyOffset(verifier, VT_FIELDS) &&
           verifier.VerifyTable(fields()) &&
           VerifyOffset(verifier, VT_METHODS) &&
           verifier.VerifyTable(methods()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           verifier.EndTable();
  }
};

struct ClassMatcherBuilder {
  typedef ClassMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_package_name(::flatbuffers::Offset<schema::StringMatcher> package_name) {
    fbb_.AddOffset(ClassMatcher::VT_PACKAGE_NAME, package_name);
  }
  void add_smali_source(::flatbuffers::Offset<schema::StringMatcher> smali_source) {
    fbb_.AddOffset(ClassMatcher::VT_SMALI_SOURCE, smali_source);
  }
  void add_simple_name(::flatbuffers::Offset<schema::StringMatcher> simple_name) {
    fbb_.AddOffset(ClassMatcher::VT_SIMPLE_NAME, simple_name);
  }
  void add_access_flags(::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags) {
    fbb_.AddOffset(ClassMatcher::VT_ACCESS_FLAGS, access_flags);
  }
  void add_super_class(::flatbuffers::Offset<schema::ClassMatcher> super_class) {
    fbb_.AddOffset(ClassMatcher::VT_SUPER_CLASS, super_class);
  }
  void add_interfaces(::flatbuffers::Offset<schema::InterfacesMatcher> interfaces) {
    fbb_.AddOffset(ClassMatcher::VT_INTERFACES, interfaces);
  }
  void add_annotations(::flatbuffers::Offset<schema::AnnotationsMatcher> annotations) {
    fbb_.AddOffset(ClassMatcher::VT_ANNOTATIONS, annotations);
  }
  void add_fields(::flatbuffers::Offset<schema::FieldsMatcher> fields) {
    fbb_.AddOffset(ClassMatcher::VT_FIELDS, fields);
  }
  void add_methods(::flatbuffers::Offset<schema::MethodsMatcher> methods) {
    fbb_.AddOffset(ClassMatcher::VT_METHODS, methods);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(ClassMatcher::VT_USING_STRINGS, using_strings);
  }
  explicit ClassMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClassMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClassMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClassMatcher> CreateClassMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> package_name = 0,
    ::flatbuffers::Offset<schema::StringMatcher> smali_source = 0,
    ::flatbuffers::Offset<schema::StringMatcher> simple_name = 0,
    ::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> super_class = 0,
    ::flatbuffers::Offset<schema::InterfacesMatcher> interfaces = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::FieldsMatcher> fields = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> methods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings = 0) {
  ClassMatcherBuilder builder_(_fbb);
  builder_.add_using_strings(using_strings);
  builder_.add_methods(methods);
  builder_.add_fields(fields);
  builder_.add_annotations(annotations);
  builder_.add_interfaces(interfaces);
  builder_.add_super_class(super_class);
  builder_.add_access_flags(access_flags);
  builder_.add_simple_name(simple_name);
  builder_.add_smali_source(smali_source);
  builder_.add_package_name(package_name);
  return builder_.Finish();
}

struct ClassMatcher::Traits {
  using type = ClassMatcher;
  static auto constexpr Create = CreateClassMatcher;
};

inline ::flatbuffers::Offset<ClassMatcher> CreateClassMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<schema::StringMatcher> package_name = 0,
    ::flatbuffers::Offset<schema::StringMatcher> smali_source = 0,
    ::flatbuffers::Offset<schema::StringMatcher> simple_name = 0,
    ::flatbuffers::Offset<schema::AccessFlagsMatcher> access_flags = 0,
    ::flatbuffers::Offset<schema::ClassMatcher> super_class = 0,
    ::flatbuffers::Offset<schema::InterfacesMatcher> interfaces = 0,
    ::flatbuffers::Offset<schema::AnnotationsMatcher> annotations = 0,
    ::flatbuffers::Offset<schema::FieldsMatcher> fields = 0,
    ::flatbuffers::Offset<schema::MethodsMatcher> methods = 0,
    const std::vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings = nullptr) {
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<schema::StringMatcher>>(*using_strings) : 0;
  return schema::CreateClassMatcher(
      _fbb,
      package_name,
      smali_source,
      simple_name,
      access_flags,
      super_class,
      interfaces,
      annotations,
      fields,
      methods,
      using_strings__);
}

struct BatchUsingStringsMatcher FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchUsingStringsMatcherBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UNION_ID = 4,
    VT_USING_STRINGS = 6
  };
  const ::flatbuffers::String *union_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNION_ID);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>> *>(VT_USING_STRINGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UNION_ID) &&
           verifier.VerifyString(union_id()) &&
           VerifyOffset(verifier, VT_USING_STRINGS) &&
           verifier.VerifyVector(using_strings()) &&
           verifier.VerifyVectorOfTables(using_strings()) &&
           verifier.EndTable();
  }
};

struct BatchUsingStringsMatcherBuilder {
  typedef BatchUsingStringsMatcher Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_union_id(::flatbuffers::Offset<::flatbuffers::String> union_id) {
    fbb_.AddOffset(BatchUsingStringsMatcher::VT_UNION_ID, union_id);
  }
  void add_using_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings) {
    fbb_.AddOffset(BatchUsingStringsMatcher::VT_USING_STRINGS, using_strings);
  }
  explicit BatchUsingStringsMatcherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchUsingStringsMatcher> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchUsingStringsMatcher>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchUsingStringsMatcher> CreateBatchUsingStringsMatcher(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> union_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<schema::StringMatcher>>> using_strings = 0) {
  BatchUsingStringsMatcherBuilder builder_(_fbb);
  builder_.add_using_strings(using_strings);
  builder_.add_union_id(union_id);
  return builder_.Finish();
}

struct BatchUsingStringsMatcher::Traits {
  using type = BatchUsingStringsMatcher;
  static auto constexpr Create = CreateBatchUsingStringsMatcher;
};

inline ::flatbuffers::Offset<BatchUsingStringsMatcher> CreateBatchUsingStringsMatcherDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *union_id = nullptr,
    const std::vector<::flatbuffers::Offset<schema::StringMatcher>> *using_strings = nullptr) {
  auto union_id__ = union_id ? _fbb.CreateString(union_id) : 0;
  auto using_strings__ = using_strings ? _fbb.CreateVector<::flatbuffers::Offset<schema::StringMatcher>>(*using_strings) : 0;
  return schema::CreateBatchUsingStringsMatcher(
      _fbb,
      union_id__,
      using_strings__);
}

inline bool VerifyAnnotationElementValueMatcher(::flatbuffers::Verifier &verifier, const void *obj, AnnotationElementValueMatcher type) {
  switch (type) {
    case AnnotationElementValueMatcher::NONE: {
      return true;
    }
    case AnnotationElementValueMatcher::EncodeValueBoolean: {
      auto ptr = reinterpret_cast<const schema::EncodeValueBoolean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueByte: {
      auto ptr = reinterpret_cast<const schema::EncodeValueByte *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueShort: {
      auto ptr = reinterpret_cast<const schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueChar: {
      auto ptr = reinterpret_cast<const schema::EncodeValueChar *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueInt: {
      auto ptr = reinterpret_cast<const schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueLong: {
      auto ptr = reinterpret_cast<const schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::StringMatcher: {
      auto ptr = reinterpret_cast<const schema::StringMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::ClassMatcher: {
      auto ptr = reinterpret_cast<const schema::ClassMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::AnnotationElementsMatcher: {
      auto ptr = reinterpret_cast<const schema::AnnotationElementsMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnnotationElementValueMatcher::AnnotationMatcher: {
      auto ptr = reinterpret_cast<const schema::AnnotationMatcher *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAnnotationElementValueMatcherVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AnnotationElementValueMatcher> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnnotationElementValueMatcher(
        verifier,  values->Get(i), types->GetEnum<AnnotationElementValueMatcher>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyNumber(::flatbuffers::Verifier &verifier, const void *obj, Number type) {
  switch (type) {
    case Number::NONE: {
      return true;
    }
    case Number::EncodeValueShort: {
      auto ptr = reinterpret_cast<const schema::EncodeValueShort *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueInt: {
      auto ptr = reinterpret_cast<const schema::EncodeValueInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueLong: {
      auto ptr = reinterpret_cast<const schema::EncodeValueLong *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueFloat: {
      auto ptr = reinterpret_cast<const schema::EncodeValueFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Number::EncodeValueDouble: {
      auto ptr = reinterpret_cast<const schema::EncodeValueDouble *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyNumberVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Number> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyNumber(
        verifier,  values->Get(i), types->GetEnum<Number>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema

#endif  // FLATBUFFERS_GENERATED_MATCHERS_SCHEMA_H_
